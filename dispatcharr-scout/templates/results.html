<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Results - Dispatcharr Maid</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='logo.svg') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='brand.css') }}">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .nav-buttons { text-align: center; margin-bottom: 20px; }
        .btn { padding: 12px 30px; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; background: white; color: #667eea; margin: 0 10px; transition: all 0.3s; text-decoration: none; display: inline-block; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .card { background: white; border-radius: 15px; padding: 25px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; border-bottom: 2px solid #667eea; padding-bottom: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-box { background: #f7fafc; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; }
        .stat-label { color: #718096; font-size: 0.9em; margin-bottom: 5px; }
        .stat-value { font-size: 2em; font-weight: bold; color: #2d3748; }
        .stat-value.success { color: #38a169; }
        .stat-value.failed { color: #e53e3e; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #eef2ff; color: #667eea; font-weight: 600; }
        tr:hover { background: #f7fafc; }
        .success-badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.9em; font-weight: 600; }
        .success-badge.excellent { background: #c6f6d5; color: #22543d; }
        .success-badge.good { background: #bee3f8; color: #2c5282; }
        .success-badge.fair { background: #feebc8; color: #7c2d12; }
        .success-badge.poor { background: #fed7d7; color: #742a2a; }
        .capacity-warning { margin-top: 12px; color: #97266d; font-weight: 600; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; }
        .tab { padding: 12px 24px; cursor: pointer; border: none; background: none; font-size: 1em; font-weight: 600; color: #718096; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .muted { color: #718096; }
        .small { font-size: 0.9em; }
        .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background: #edf2f7; color:#2d3748; font-weight: 600; font-size: 0.85em; }
        .btn-sm { padding: 10px 14px; border-radius: 8px; font-size: 0.95em; }
        .input { width: 100%; padding: 10px 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 1em; }
        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
        .stream-tools { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
        .codebox { margin-top: 10px; padding: 12px; background: #f7fafc; border-radius: 10px; border: 1px solid #e2e8f0; }
        code { word-break: break-word; }
        .stream-table-wrap { overflow-x: auto; }
        .plan-meta { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-top:10px; color:#4a5568; }
        .plan-meta .pill { background:#eef2ff; color:#3730a3; }
        .plan-card { border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px; background: #fbfdff; }
        .plan-row-title { display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:baseline; }
        .plan-row-title strong { color:#2d3748; }
        .plan-badges { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .badge { display:inline-block; padding: 3px 10px; border-radius: 999px; font-weight: 700; font-size: 0.82em; }
        .badge.changed { background:#fefcbf; color:#744210; }
        .badge.unchanged { background:#edf2f7; color:#4a5568; }
        .badge.added { background:#c6f6d5; color:#22543d; }
        .badge.removed { background:#fed7d7; color:#742a2a; }
        .plan-streams { margin-top: 10px; display:grid; grid-template-columns: 1fr; gap: 8px; }
        .plan-stream { padding: 8px 10px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 10px; }
        .plan-stream-line { display:flex; gap:8px; flex-wrap:wrap; align-items:baseline; }
        .plan-stream-line .muted { color:#718096; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        details summary { cursor: pointer; }
        .plan-actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brand">
                <img class="brand-logo" src="{{ url_for('static', filename='logo.svg') }}" alt="Dispatcharr Maid">
                <div class="brand-text">
                    <h1>Analysis Results</h1>
                    <p>Detailed Stream Quality Report</p>
                </div>
            </div>
        </div>
        
        <div class="nav-buttons">
            <a href="/" class="btn">‚Üê Back to Control Panel</a>
            <a href="/api/results/csv" class="btn" id="export-csv-link">üì• Export CSV</a>
            <span style="display:inline-block;color:white;font-weight:600;margin-left:10px;">Run:</span>
            <select id="job-picker" class="input" style="display:inline-block; width:auto; min-width: 320px; max-width: 520px; margin-left:8px;"></select>
        </div>
        
        <div class="card">
            <h2>üìà Overall Summary</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Total Streams Analyzed</div>
                    <div class="stat-value" id="stat-total">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Successful</div>
                    <div class="stat-value success" id="stat-success">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value failed" id="stat-failed">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="stat-rate">0%</div>
                </div>
            </div>
            <div id="capacity-warning" class="capacity-warning" style="display:none;"></div>
        </div>

        <div class="card" id="ordering-visibility-card" style="display:none;">
            <h2>‚úÖ Final Channel Stream Order</h2>
            <div class="muted small">Displays the exact order written back to Dispatcharr and the streams that were excluded with their reasons.</div>
            <div class="stream-table-wrap">
                <table id="final-order-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>#</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Codec</th>
                            <th>Bitrate</th>
                            <th>Validation</th>
                            <th>Final Score</th>
                        </tr>
                    </thead>
                    <tbody id="final-order-tbody"></tbody>
                </table>
            </div>

            <h3 style="margin-top: 20px;">üö´ Excluded Streams</h3>
            <div class="stream-table-wrap">
                <table id="excluded-stream-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                            <th>Reason</th>
                        </tr>
                    </thead>
                    <tbody id="excluded-stream-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="detailed-breakdown-card">
            <h2>üîç Detailed Breakdown</h2>
            <div class="tabs">
                <button class="tab active" onclick="showTab('streams', this)">Streams</button>
                <button class="tab" onclick="showTab('providers', this)">Providers</button>
                <button class="tab" onclick="showTab('channels', this)">Channels</button>
                <button class="tab" onclick="showTab('errors', this)">Errors</button>
                <button class="tab" onclick="showTab('plan', this)">Planned Changes</button>
            </div>
            
            <div id="providers-tab" class="tab-content">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin: 10px 0 0 0;">
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        <input type="checkbox" id="show-all-providers" />
                        Show all providers (including 0 streams)
                    </label>
                    <div id="provider-count-note" style="color:#718096;font-size:0.95em;"></div>
                </div>
                <table id="provider-table">
                    <thead>
                        <tr>
                            <th>Provider</th>
                            <th>Total Streams</th>
                            <th>Successful</th>
                            <th>Failed</th>
                            <th>Success Rate</th>
                            <th>Avg Quality</th>
                            <th>Max Streams</th>
                        </tr>
                    </thead>
                    <tbody id="provider-tbody"></tbody>
                </table>
            </div>
            
            <div id="channels-tab" class="tab-content">
                <table id="channel-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Total Streams</th>
                            <th>Successful</th>
                            <th>Failed</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody id="channel-tbody"></tbody>
                </table>
            </div>
            
            <div id="errors-tab" class="tab-content">
                <div id="error-list"></div>
            </div>

            <div id="plan-tab" class="tab-content">
                <div class="row" style="justify-content: space-between; margin-top: 6px;">
                    <div class="muted small">
                        Plan-only runs generate an exact <strong>before vs after</strong> stream list per channel, but do <strong>not</strong> update Dispatcharr.
                    </div>
                    <div class="pill" id="plan-count-pill">0 channels</div>
                </div>

                <div class="stream-tools" style="margin-top: 12px;">
                    <input id="plan-search" class="input" style="max-width: 520px;" type="text" placeholder="üîç Filter channels (client-side)" oninput="renderPlanRows()" />
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        <input type="checkbox" id="plan-changed-only" checked />
                        Show changed only
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        Preview size
                        <select id="plan-preview-limit" class="input" style="width:auto;">
                            <option value="30">30</option>
                            <option value="60" selected>60</option>
                            <option value="120">120</option>
                            <option value="200">200</option>
                        </select>
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        <input type="checkbox" id="plan-include-before" />
                        Include ‚Äúbefore‚Äù preview
                    </label>
                    <button class="btn btn-sm" type="button" onclick="selectAllPlannedChannels()">Select all (visible)</button>
                    <button class="btn btn-sm" type="button" onclick="clearPlannedSelection()">Clear selection</button>
                    <button class="btn btn-sm" type="button" id="plan-commit-btn" style="background:#38a169;color:white;" onclick="commitPlan()" disabled>
                        ‚úÖ Commit planned changes
                    </button>
                    <span id="plan-status" class="muted small"></span>
                    <span id="plan-commit-status" class="muted small"></span>
                </div>

                <div id="plan-meta" class="plan-meta"></div>
                <div id="plan-list" style="margin-top: 12px;"></div>
            </div>

            <div id="streams-tab" class="tab-content active">
                <div class="row" style="justify-content: space-between; margin-top: 6px;">
                    <div class="muted small">
                        Tick streams you want the regex to <strong>match</strong>. Untick streams you want it to <strong>exclude</strong> (e.g. untick any ‚Äúdolby‚Äù variants).
                    </div>
                    <div class="pill" id="streams-count-pill">0 streams</div>
                </div>

                <div class="stream-tools">
                    <input id="stream-search" class="input" style="max-width: 520px;" type="text" placeholder="üîç Filter streams by name (client-side)" oninput="filterStreamRows()" />
                    <button class="btn btn-sm" type="button" onclick="selectAllStreams()">Select all</button>
                    <button class="btn btn-sm" type="button" onclick="clearAllStreams()">Clear all</button>
                    <button class="btn btn-sm" type="button" style="background:#667eea;color:white;" onclick="generateStreamRegex()">Generate minimal regex</button>
                    <button class="btn btn-sm" type="button" onclick="copyStreamRegex()" id="copy-stream-regex-btn" disabled>Copy regex</button>
                    <span id="stream-regex-status" class="muted small"></span>
                </div>

                <div id="stream-regex-output" class="codebox" style="display:none;">
                    <div style="font-weight:700; color:#2d3748; margin-bottom:6px;">Suggested regex</div>
                    <code id="stream-regex-code"></code>
                </div>

                <div class="stream-table-wrap">
                    <table id="stream-table">
                        <thead>
                            <tr>
                                <th style="width: 70px;">Use</th>
                                <th>Stream</th>
                                <th>Status</th>
                                <th>Quality</th>
                                <th>Resolution</th>
                                <th>Provider</th>
                            </tr>
                        </thead>
                        <tbody id="stream-tbody"></tbody>
                    </table>
                </div>
                <div id="streams-loading" class="muted small" style="margin-top:10px;"></div>
            </div>
        </div>

        <div class="card" id="refresh-breakdown-card" style="display:none;">
            <h2>üîÑ Refresh Stream Changes</h2>
            <div class="muted small">Comparison of the channel before and after refresh. Status is derived from the original list and the final replacement list.</div>
            <div class="stream-table-wrap">
                <table id="refresh-change-table">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                        </tr>
                    </thead>
                    <tbody id="refresh-change-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="run-meta-card" style="display:none;">
            <h2>üßæ Run Details</h2>
            <div id="run-meta-body" class="muted small"></div>
        </div>
    </div>

    <script>
        const params = new URLSearchParams(window.location.search);
        const jobId = params.get('job_id');
        const resultsUrl = jobId ? `/api/results/job/${encodeURIComponent(jobId)}` : '/api/results/detailed';
        let streamsLoaded = false;
        let planLoaded = false;
        let planAvailable = false;
        // Populated from the detailed results payload; reused by the Streams tab.
        let providerNames = {};
        let providerMetadata = {};

        function escapeHtml(str) {
            const s = String(str ?? '');
            return s.replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[c]));
        }

        function showWarning(title, message) {
            document.body.innerHTML = `
                <div style="text-align:center;padding:40px;color:white;">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <a href="/" style="color:white;">Go Back</a>
                </div>
            `;
        }

        function providerLabelHtml(providerId) {
            if ((providerId ?? '') === '') return '';
            const pid = String(providerId);
            const label = Object.prototype.hasOwnProperty.call(providerNames, pid)
                ? providerNames[pid]
                : `Provider ${pid}`;
            return `<span title="Provider ${escapeHtml(pid)}">${escapeHtml(String(label))}</span>`;
        }

        function setExportLink() {
            const link = document.getElementById('export-csv-link');
            if (!link) return;
            link.href = jobId ? `/api/results/csv?job_id=${encodeURIComponent(jobId)}` : '/api/results/csv';
        }

        function fmtIso(iso) {
            if (!iso) return '';
            try {
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return String(iso);
                return d.toLocaleString();
            } catch {
                return String(iso);
            }
        }

        function fmtBitrate(kbps) {
            if (kbps === null || kbps === undefined || kbps === 'N/A') return '‚Äî';
            const num = Number(kbps);
            if (Number.isNaN(num)) return escapeHtml(String(kbps));
            return `${num.toLocaleString()} kbps`;
        }

        function channelLabelFrom(row) {
            if (!row || typeof row !== 'object') return 'Unknown channel';
            const labelRow = {
                channel_number: row.channel_number,
                channel_name: row.channel_name,
                channel_id: row.channel_id
            };
            return fmtChannelLabel(labelRow);
        }

        function renderJobMeta(meta) {
            const card = document.getElementById('run-meta-card');
            const body = document.getElementById('run-meta-body');
            if (!card || !body) return;
            if (!meta || typeof meta !== 'object') {
                card.style.display = 'none';
                body.innerHTML = '';
                return;
            }

            const selection = meta.selection || {};
            const groupIds = Array.isArray(selection.channel_group_ids) ? selection.channel_group_ids : [];
            const channelIds = Array.isArray(selection.specific_channel_ids) ? selection.specific_channel_ids : [];
            const nameRegex = selection.channel_name_regex || '';
            const numRegex = selection.channel_number_regex || '';
            const refreshRegex = selection.refresh_stream_name_regex || '';

            const selectionLines = [];
            if (groupIds.length) selectionLines.push(`<div><strong>Groups (config)</strong>: ${escapeHtml(groupIds.join(', '))}</div>`);
            if (channelIds.length) selectionLines.push(`<div><strong>Specific channels (config)</strong>: ${escapeHtml(channelIds.slice(0, 50).join(', '))}${channelIds.length > 50 ? '‚Ä¶' : ''}</div>`);
            if (nameRegex) selectionLines.push(`<div><strong>Channel name regex</strong>: <code>${escapeHtml(nameRegex)}</code></div>`);
            if (numRegex) selectionLines.push(`<div><strong>Channel number regex</strong>: <code>${escapeHtml(numRegex)}</code></div>`);
            if (refreshRegex) selectionLines.push(`<div><strong>Refresh stream regex</strong>: <code>${escapeHtml(refreshRegex)}</code></div>`);

            const chosen = [];
            if (meta.group_names) chosen.push(`<div><strong>Selected</strong>: ${escapeHtml(String(meta.group_names))}${meta.channel_names ? ` ‚Äî ${escapeHtml(String(meta.channel_names))}` : ''}</div>`);
            if (meta.regex_preset_name) chosen.push(`<div><strong>Saved Job</strong>: ${escapeHtml(String(meta.regex_preset_name))}</div>`);
            if (meta.selection_pattern_name) chosen.push(`<div><strong>Pattern</strong>: ${escapeHtml(String(meta.selection_pattern_name))}</div>`);

            const runLines = [
                `<div><strong>Job</strong>: ${escapeHtml(String(meta.job_id || 'latest'))}</div>`,
                meta.job_type ? `<div><strong>Type</strong>: ${escapeHtml(String(meta.job_type))}</div>` : '',
                meta.status ? `<div><strong>Status</strong>: ${escapeHtml(String(meta.status))}</div>` : '',
                meta.started_at ? `<div><strong>Started</strong>: ${escapeHtml(fmtIso(meta.started_at))}</div>` : '',
                meta.completed_at ? `<div><strong>Completed</strong>: ${escapeHtml(fmtIso(meta.completed_at))}</div>` : '',
                meta.config_hash ? `<div><strong>Config hash</strong>: <code>${escapeHtml(String(meta.config_hash))}</code></div>` : '',
            ].filter(Boolean);

            const refreshLines = [];
            if (meta.base_search_text) refreshLines.push(`<div><strong>Primary Match</strong>: ${escapeHtml(String(meta.base_search_text))}</div>`);
            if (meta.include_filter) refreshLines.push(`<div><strong>Include filter</strong>: ${escapeHtml(String(meta.include_filter))}</div>`);
            if (meta.exclude_filter) refreshLines.push(`<div><strong>Exclude filter</strong>: ${escapeHtml(String(meta.exclude_filter))}</div>`);
            if (meta.exclude_plus_one === true) refreshLines.push(`<div><strong>Exclude +1</strong>: true</div>`);
            if (meta.stream_name_regex) refreshLines.push(`<div><strong>Advanced Regex (layered)</strong>: <code>${escapeHtml(String(meta.stream_name_regex))}</code></div>`);
            if (meta.stream_name_regex_override) refreshLines.push(`<div><strong>Advanced Regex (regex-only)</strong>: <code>${escapeHtml(String(meta.stream_name_regex_override))}</code></div>`);

            const sections = []
                .concat(chosen.length ? [`<div style="margin-bottom:10px;">${chosen.join('')}</div>`] : [])
                .concat(runLines.length ? [`<div style="margin-bottom:10px;">${runLines.join('')}</div>`] : [])
                .concat(selectionLines.length ? [`<div style="margin-bottom:10px;">${selectionLines.join('')}</div>`] : [])
                .concat(refreshLines.length ? [`<div>${refreshLines.join('')}</div>`] : []);

            body.innerHTML = sections.length ? sections.join('') : '<div class="muted">No run metadata available.</div>';
            card.style.display = '';
        }

        async function loadJobPicker() {
            const picker = document.getElementById('job-picker');
            if (!picker) return;

            // Default option (no job_id => latest)
            picker.innerHTML = `<option value="">Latest</option>`;

            try {
                const resp = await fetch('/api/job-history');
                const data = await resp.json();
                const history = (data && data.success && Array.isArray(data.history)) ? data.history : [];

                // Only show completed jobs first (others can appear but won't have stable results).
                const completed = history.filter(j => j && typeof j === 'object' && j.status === 'completed');
                completed.forEach((j) => {
                    const id = j.job_id;
                    if (!id) return;
                    const started = fmtIso(j.started_at);
                    const typ = j.job_type || 'job';
                    const sel = (j.group_names || '').toString();
                    const label = `${started} ‚Äî ${typ}${sel ? ` ‚Äî ${sel}` : ''}`.trim();
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = label;
                    picker.appendChild(opt);
                });
            } catch {
                // ignore picker load failures; page still works
            }

            // Select current job.
            picker.value = jobId || '';
            picker.addEventListener('change', (e) => {
                const v = e.target && e.target.value ? String(e.target.value) : '';
                window.location.href = v ? `/results?job_id=${encodeURIComponent(v)}` : '/results';
            });
        }

        setExportLink();
        loadJobPicker();

        function refreshStreamProviderLabels() {
            document.querySelectorAll('#stream-tbody .stream-row').forEach((row) => {
                const pid = row.getAttribute('data-provider-id') || '';
                const cell = row.querySelector('td:nth-child(6)');
                if (cell) cell.innerHTML = providerLabelHtml(pid);
            });
        }

        function renderRefreshBreakdown(summary) {
            const card = document.getElementById('refresh-breakdown-card');
            const tbody = document.getElementById('refresh-change-tbody');
            if (!card || !tbody) return;

            const previous = Array.isArray(summary?.previous_streams) ? summary.previous_streams : [];
            const finalStreams = Array.isArray(summary?.final_streams)
                ? summary.final_streams
                : (Array.isArray(summary?.streams) ? summary.streams : []);

            const finalIds = new Set(finalStreams.map((s) => String(s?.id ?? s?.stream_id ?? '')));
            const previousIds = new Set(previous.map((s) => String(s?.id ?? s?.stream_id ?? '')));

            const rows = [];

            finalStreams.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                const status = previousIds.has(id) ? 'Kept' : 'Added';
                rows.push({ ...s, status });
            });

            previous.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                if (!finalIds.has(id)) {
                    rows.push({ ...s, status: 'Removed' });
                }
            });

            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="5" class="muted">No stream details available for this refresh.</td></tr>';
                card.style.display = '';
                return;
            }

            tbody.innerHTML = rows.map((row) => {
                const name = row?.name || row?.stream_name || `Stream ${row?.id ?? ''}`;
                const pid = row?.provider_id ?? row?.providerid ?? row?.provider;
                const providerCell = providerLabelHtml(pid ?? row?.provider_name) || escapeHtml(row?.provider_name || '');
                const resolution = escapeHtml(row?.resolution || '‚Äî');
                const bitrate = fmtBitrate(row?.bitrate_kbps);
                const statusClass = row.status === 'Removed' ? 'badge removed' : (row.status === 'Added' ? 'badge added' : 'badge unchanged');
                return `
                    <tr>
                        <td><span class="${statusClass}">${escapeHtml(row.status || '')}</span></td>
                        <td>${escapeHtml(String(name))}</td>
                        <td>${providerCell}</td>
                        <td>${resolution}</td>
                        <td>${bitrate}</td>
                    </tr>
                `;
            }).join('');

            card.style.display = '';
        }

        function renderOrderingTables(ordering) {
            const card = document.getElementById('ordering-visibility-card');
            if (!card) return;
            const finalBody = document.getElementById('final-order-tbody');
            const excludedBody = document.getElementById('excluded-stream-tbody');
            if (!finalBody || !excludedBody) return;

            const finalOrders = Array.isArray(ordering?.final_orders) ? ordering.final_orders : [];
            const excluded = Array.isArray(ordering?.excluded_streams) ? ordering.excluded_streams : [];

            if (!finalOrders.length && !excluded.length) {
                card.style.display = 'none';
                return;
            }

            const sortedFinal = [...finalOrders].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const orderA = Number(a?.order ?? 0);
                const orderB = Number(b?.order ?? 0);
                return orderA - orderB;
            });

            finalBody.innerHTML = sortedFinal.map((row) => {
                const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                const validation = row?.validation_result ? escapeHtml(String(row.validation_result)) : '‚Äî';
                const score = row?.final_score;
                const scoreText = score === null || score === undefined ? '‚Äî' : escapeHtml(Number(score).toFixed ? Number(score).toFixed(1) : String(score));
                return `
                    <tr>
                        <td>${channelLabelFrom(row)}</td>
                        <td class="mono">${escapeHtml(row?.order ?? '')}</td>
                        <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                        <td>${providerCell}</td>
                        <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                        <td>${escapeHtml(row?.video_codec || '‚Äî')}</td>
                        <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                        <td>${validation}</td>
                        <td>${scoreText}</td>
                    </tr>
                `;
            }).join('');

            const sortedExcluded = [...excluded].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const nameA = (a?.stream_name || '').toString().toLowerCase();
                const nameB = (b?.stream_name || '').toString().toLowerCase();
                return nameA.localeCompare(nameB);
            });

            excludedBody.innerHTML = sortedExcluded.map((row) => {
                const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                return `
                    <tr>
                        <td>${channelLabelFrom(row)}</td>
                        <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                        <td>${providerCell}</td>
                        <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                        <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                        <td>${escapeHtml(row?.reason || '‚Äî')}</td>
                    </tr>
                `;
            }).join('');

            if (!excluded.length) {
                excludedBody.innerHTML = '<tr><td colspan="6" class="muted">No streams were excluded.</td></tr>';
            }

            card.style.display = '';
        }

        fetch(resultsUrl)
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.body.innerHTML = '<div style="text-align:center;padding:40px;color:white;"><h2>No results available</h2><p>Run an analysis first.</p><a href="/" style="color:white;">Go Back</a></div>';
                    return;
                }
                
                const r = data.results;
                providerNames = data.provider_names || {};
                providerMetadata = data.provider_metadata || {};
                renderJobMeta(data.job_meta || null);
                if (streamsLoaded) refreshStreamProviderLabels();
                const jobType = r.job_type || data.job_type;
                const analyzedStreams = typeof data.analyzed_streams === 'number'
                    ? data.analyzed_streams
                    : (typeof r.total === 'number' ? r.total : 0);
                
                // Check if this is a refresh job
                if (jobType === 'refresh') {
                    // Show refresh-specific results
                    document.querySelector('.header h1').textContent = 'üîÑ Channel Refresh Results';
                    document.querySelector('.header p').textContent = 'Stream Replacement Summary';
                    
                    document.getElementById('stat-total').textContent = r.total_matching.toLocaleString();
                    document.querySelector('#stat-total').previousElementSibling.textContent = 'Total Matching Streams Found';
                    
                    document.getElementById('stat-success').textContent = r.new_count.toLocaleString();
                    document.querySelector('#stat-success').previousElementSibling.textContent = 'Streams Added';
                    
                    document.getElementById('stat-failed').textContent = r.previous_count.toLocaleString();
                    document.querySelector('#stat-failed').previousElementSibling.textContent = 'Streams Removed';
                    document.querySelector('#stat-failed').classList.remove('failed');
                    document.querySelector('#stat-failed').style.color = '#718096';
                    
                    document.getElementById('stat-rate').textContent = 'Refresh Complete';
                    document.querySelector('#stat-rate').previousElementSibling.textContent = 'Status';
                    
                    // Hide the detailed breakdown section
                    const breakdownCard = document.getElementById('detailed-breakdown-card');
                    if (breakdownCard) {
                        breakdownCard.style.display = 'none';
                    }
                    
                    // Add filter info if present
                    if (r.include_filter || r.exclude_filter) {
                        const filterCard = document.createElement('div');
                        filterCard.className = 'card';
                        filterCard.innerHTML = `
                            <h2>üîç Filters Applied</h2>
                            ${r.include_filter ? `<p><strong>Include:</strong> ${r.include_filter}</p>` : ''}
                            ${r.exclude_filter ? `<p><strong>Exclude:</strong> ${r.exclude_filter}</p>` : ''}
                        `;
                        document.querySelectorAll('.card')[0].after(filterCard);
                    }

                    renderRefreshBreakdown(r);

                    return;
                }

                if (data.analysis_ran === false) {
                    showWarning('No analysis ran for this job', 'This job did not execute stream analysis.');
                    return;
                }

                if (analyzedStreams === 0) {
                    showWarning('No analysis results', 'Stream analysis ran but produced zero analyzed streams.');
                    return;
                }
                
                // Otherwise, show analysis results
                document.getElementById('stat-total').textContent = r.total.toLocaleString();
                document.getElementById('stat-success').textContent = r.successful.toLocaleString();
                document.getElementById('stat-failed').textContent = r.failed.toLocaleString();
                document.getElementById('stat-rate').textContent = r.success_rate + '%';
                const capacitySummary = r.capacity_summary || data.capacity_summary;
                if (capacitySummary && capacitySummary.warning) {
                    const capacityEl = document.getElementById('capacity-warning');
                    capacityEl.textContent = capacitySummary.warning;
                    capacityEl.style.display = 'block';
                }

                const orderingVisibility = data.ordering_visibility || r.ordering_visibility;
                renderOrderingTables(orderingVisibility);

                // Providers
                const tbody = document.getElementById('provider-tbody');
                const providerCountNote = document.getElementById('provider-count-note');
                const showAllProvidersEl = document.getElementById('show-all-providers');

                function renderProviders(showAll) {
                    const providerStats = r.provider_stats || {};
                    const providerStatsEntries = Object.entries(providerStats);
                    const configuredProviderIds = Object.keys(providerNames || {});

                    // If we don't have a configured provider list, fall back to what the run produced.
                    const providerIds = (showAll && configuredProviderIds.length > 0)
                        ? configuredProviderIds
                        : providerStatsEntries.map(([id]) => id);

                    const rows = providerIds.map((id) => {
                        const stats = Object.prototype.hasOwnProperty.call(providerStats, id)
                            ? providerStats[id]
                            : { total: 0, successful: 0, failed: 0, success_rate: 0, avg_quality: '‚Äî' };
                        return [id, stats];
                    });

                    // Sort: providers with data first, then by success rate (ascending like before), then by name.
                    rows.sort((a, b) => {
                        const aHasData = (a[1]?.total || 0) > 0;
                        const bHasData = (b[1]?.total || 0) > 0;
                        if (aHasData !== bHasData) return aHasData ? -1 : 1;
                        const aRate = typeof a[1]?.success_rate === 'number' ? a[1].success_rate : 0;
                        const bRate = typeof b[1]?.success_rate === 'number' ? b[1].success_rate : 0;
                        if (aRate !== bRate) return aRate - bRate;
                        const aName = Object.prototype.hasOwnProperty.call(providerNames, a[0]) ? providerNames[a[0]] : `${a[0]}`;
                        const bName = Object.prototype.hasOwnProperty.call(providerNames, b[0]) ? providerNames[b[0]] : `${b[0]}`;
                        return aName.localeCompare(bName);
                    });

                    providerCountNote.textContent = `Showing ${providerStatsEntries.length} provider${providerStatsEntries.length === 1 ? '' : 's'} in this run` +
                        (configuredProviderIds.length > 0 ? ` (configured: ${configuredProviderIds.length})` : '');

                    if (rows.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="7" class="muted" style="text-align:center;padding:20px;">No provider data available.</td></tr>';
                    } else {
                        tbody.innerHTML = rows.map(([id, stats]) => {
                            const rate = typeof stats.success_rate === 'number' ? stats.success_rate : 0;
                            const badgeClass = rate >= 90 ? 'excellent' : rate >= 70 ? 'good' : rate >= 50 ? 'fair' : 'poor';
                            const providerLabel = Object.prototype.hasOwnProperty.call(providerNames, id)
                                ? providerNames[id]
                                : `Provider ${id}`;
                            const providerMeta = providerMetadata[id] || {};
                            const maxStreams = typeof providerMeta.max_streams === 'number'
                                ? providerMeta.max_streams
                                : (providerMeta.max_streams === 0 ? 0 : '‚Äî');
                            const avgQuality = (stats.avg_quality === undefined || stats.avg_quality === null) ? '‚Äî' : stats.avg_quality;
                            const total = typeof stats.total === 'number' ? stats.total : 0;
                            const successful = typeof stats.successful === 'number' ? stats.successful : 0;
                            const failed = typeof stats.failed === 'number' ? stats.failed : 0;

                            return `<tr>
                                <td>${providerLabel}</td>
                                <td>${total}</td>
                                <td style="color: #38a169;">${successful}</td>
                                <td style="color: #e53e3e;">${failed}</td>
                                <td><span class="success-badge ${badgeClass}">${rate}%</span></td>
                                <td>${avgQuality}</td>
                                <td>${maxStreams}</td>
                            </tr>`;
                        }).join('');
                    }
                }

                // Default view matches prior behavior (only providers present in this run).
                renderProviders(false);
                showAllProvidersEl.checked = false;
                showAllProvidersEl.addEventListener('change', (e) => {
                    renderProviders(Boolean(e.target && e.target.checked));
                });
                
                // Channels
                const chanTbody = document.getElementById('channel-tbody');
                const channels = Object.entries(r.channel_stats || {}).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                
                if (channels.length === 0) {
                    chanTbody.innerHTML = '<tr><td colspan="5" class="muted" style="text-align:center;padding:20px;">No channel data available.</td></tr>';
                } else {
                    chanTbody.innerHTML = channels.map(([num, stats]) => {
                        const badgeClass = stats.success_rate >= 90 ? 'excellent' : stats.success_rate >= 70 ? 'good' : stats.success_rate >= 50 ? 'fair' : 'poor';
                        return `<tr>
                            <td><strong>#${num}</strong> ${stats.name}</td>
                            <td>${stats.total}</td>
                            <td style="color: #38a169;">${stats.successful}</td>
                            <td style="color: #e53e3e;">${stats.failed}</td>
                            <td><span class="success-badge ${badgeClass}">${stats.success_rate}%</span></td>
                        </tr>`;
                    }).join('');
                }
                
                // Errors
                const errors = Object.entries(r.error_types || {}).sort((a, b) => b[1] - a[1]);
                const errDiv = document.getElementById('error-list');
                
                if (errors.length === 0) {
                    errDiv.innerHTML = '<p style="color: #38a169;">‚úÖ No errors! All streams working perfectly!</p>';
                } else {
                    errDiv.innerHTML = errors.map(([type, count]) => 
                        `<div style="padding:12px;border-left:3px solid #e53e3e;background:#fff5f5;margin-bottom:10px;border-radius:5px;">
                            <div style="font-weight:600;color:#742a2a;">${type}</div>
                            <div style="color:#718096;font-size:0.9em;">${count} occurrence${count > 1 ? 's' : ''}</div>
                        </div>`
                    ).join('');
                }

                // If Streams is the default active tab, load it immediately.
                // Use setTimeout to ensure DOM is ready and all rendering is complete
                setTimeout(() => {
                    const streamsTab = document.getElementById('streams-tab');
                    if (streamsTab && streamsTab.classList.contains('active') && !streamsLoaded) {
                        loadStreams();
                    }
                }, 50);
            })
            .catch(err => {
                console.error('Failed to load results:', err);
                showWarning('Failed to load results', 'An error occurred while loading the analysis results.');
            });
        
        function showTab(tabName, eventElement) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            if (eventElement) {
                eventElement.classList.add('active');
            } else {
                // Find the button by text content if eventElement not provided
                document.querySelectorAll('.tab').forEach(tab => {
                    if (tab.textContent.trim().toLowerCase() === tabName.toLowerCase() || 
                        (tabName === 'streams' && tab.textContent.includes('Streams')) ||
                        (tabName === 'providers' && tab.textContent.includes('Providers')) ||
                        (tabName === 'channels' && tab.textContent.includes('Channels')) ||
                        (tabName === 'errors' && tab.textContent.includes('Errors')) ||
                        (tabName === 'plan' && tab.textContent.includes('Planned'))) {
                        tab.classList.add('active');
                    }
                });
            }
            document.getElementById(tabName + '-tab').classList.add('active');

            if (tabName === 'streams' && !streamsLoaded) {
                loadStreams();
            }
            if (tabName === 'plan' && !planLoaded) {
                loadPlan();
            }
        }

        function setStreamStatus(msg) {
            const el = document.getElementById('stream-regex-status');
            if (el) el.textContent = msg || '';
        }

        function updateStreamsCount() {
            const all = document.querySelectorAll('.stream-row');
            const checked = document.querySelectorAll('.stream-row input[type="checkbox"]:checked');
            const pill = document.getElementById('streams-count-pill');
            if (pill) pill.textContent = `${checked.length}/${all.length} selected`;
        }

        async function loadStreams() {
            streamsLoaded = true;
            const loadingEl = document.getElementById('streams-loading');
            if (loadingEl) loadingEl.textContent = 'Loading streams...';

            const url = jobId
                ? `/api/results/streams?job_id=${encodeURIComponent(jobId)}&limit=2000&offset=0`
                : `/api/results/streams?limit=2000&offset=0`;

            try {
                const resp = await fetch(url);
                const data = await resp.json();
                if (!data.success) {
                    if (loadingEl) loadingEl.textContent = data.error || 'Failed to load streams.';
                    return;
                }
                const rows = Array.isArray(data.streams) ? data.streams : [];
                const tbody = document.getElementById('stream-tbody');
                if (!tbody) return;

                if (rows.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" class="muted" style="text-align:center;padding:20px;">No streams found.</td></tr>';
                } else {
                    tbody.innerHTML = rows.map((s) => {
                        const name = escapeHtml(s.stream_name || '(unnamed)');
                        const status = escapeHtml(s.status || '');
                        const quality = (typeof s.quality_score === 'number') ? s.quality_score.toFixed(1) : (s.quality_score ?? '');
                        const resolution = escapeHtml(s.resolution || '');
                        const provider = providerLabelHtml(s.provider_id);
                        const checkboxId = `use-stream-${escapeHtml(String(s.stream_id ?? Math.random()))}`;
                        return `
                            <tr class="stream-row" data-stream-name="${escapeHtml(String(s.stream_name || '')).toLowerCase()}" data-provider-id="${escapeHtml(String(s.provider_id ?? ''))}">
                                <td><input type="checkbox" id="${checkboxId}" class="stream-use-cb" checked onchange="updateStreamsCount()" /></td>
                                <td><label for="${checkboxId}" style="cursor:pointer;"><strong>${name}</strong></label></td>
                                <td>${status}</td>
                                <td>${escapeHtml(String(quality))}</td>
                                <td>${resolution}</td>
                                <td>${provider}</td>
                            </tr>
                        `;
                    }).join('');
                }

                if (loadingEl) loadingEl.textContent = rows.length ? `Loaded ${rows.length} stream rows.` : 'No streams found.';
                updateStreamsCount();
            } catch (e) {
                if (loadingEl) loadingEl.textContent = `Failed to load streams: ${e.message}`;
            }
        }

        function setPlanStatus(msg) {
            const el = document.getElementById('plan-status');
            if (el) el.textContent = msg || '';
        }

        function setPlanCommitStatus(msg) {
            const el = document.getElementById('plan-commit-status');
            if (el) el.textContent = msg || '';
        }

        function setPlanCommitEnabled(enabled) {
            const btn = document.getElementById('plan-commit-btn');
            if (!btn) return;
            btn.disabled = !enabled;
        }

        function setPlanCount(n) {
            const pill = document.getElementById('plan-count-pill');
            if (pill) pill.textContent = `${n} channel${n === 1 ? '' : 's'}`;
        }

        function fmtChannelLabel(row) {
            const num = row && row.channel_number !== undefined && row.channel_number !== null ? String(row.channel_number) : '';
            const name = row && row.channel_name ? String(row.channel_name) : '';
            const id = row && row.channel_id !== undefined && row.channel_id !== null ? String(row.channel_id) : '';
            if (num && name) return `#${escapeHtml(num)} ${escapeHtml(name)} (id ${escapeHtml(id)})`;
            if (name) return `${escapeHtml(name)} (id ${escapeHtml(id)})`;
            return `Channel ${escapeHtml(id)}`;
        }

        let planRows = [];
        let planMeta = null;
        let planProviderNames = {};
        let planSelectedChannelIds = new Set();

        function providerNameFromPlan(pid) {
            if (pid === undefined || pid === null || pid === '') return '';
            const key = String(pid);
            return (planProviderNames && Object.prototype.hasOwnProperty.call(planProviderNames, key))
                ? String(planProviderNames[key])
                : (Object.prototype.hasOwnProperty.call(providerNames, key) ? String(providerNames[key]) : `Provider ${key}`);
        }

        function streamLineHtml(s) {
            const sid = s && s.stream_id !== undefined && s.stream_id !== null ? String(s.stream_id) : '';
            const nm = s && s.stream_name ? String(s.stream_name) : '';
            const order = s && typeof s.order === 'number' ? s.order : null;
            const pid = s && (s.provider_id !== undefined && s.provider_id !== null) ? s.provider_id : null;
            const prov = s && s.provider_name ? String(s.provider_name) : (pid !== null ? providerNameFromPlan(pid) : '');
            const q = (s && typeof s.quality_score === 'number') ? s.quality_score.toFixed(1) : '';
            const res = s && s.resolution ? String(s.resolution) : '';
            const codec = s && s.video_codec ? String(s.video_codec) : '';
            const left = `${order ? `<span class="mono muted">#${order}</span>` : ''} <strong>${escapeHtml(nm || `Stream ${sid}`)}</strong>`;
            const rightBits = []
                .concat(pid !== null ? [`<span class="pill" title="Provider">${escapeHtml(prov)}</span>`] : [])
                .concat(q ? [`<span class="pill" title="Quality score">${escapeHtml(q)}</span>`] : [])
                .concat(res ? [`<span class="pill" title="Resolution">${escapeHtml(res)}</span>`] : [])
                .concat(codec ? [`<span class="pill" title="Codec">${escapeHtml(codec)}</span>`] : []);
            return `
                <div class="plan-stream">
                    <div class="plan-stream-line">
                        ${left}
                        <span class="muted mono">${escapeHtml(sid ? `(id ${sid})` : '')}</span>
                    </div>
                    ${rightBits.length ? `<div class="plan-badges" style="margin-top:6px;">${rightBits.join('')}</div>` : ''}
                </div>
            `;
        }

        async function copyText(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    return true;
                } catch {
                    return false;
                }
            }
        }

        async function copyAfterIds(channelId) {
            const row = (planRows || []).find(r => r && String(r.channel_id) === String(channelId));
            const ids = row && Array.isArray(row.after_stream_ids) ? row.after_stream_ids : [];
            const ok = await copyText(ids.join(','));
            setPlanStatus(ok ? `Copied after_stream_ids for channel ${channelId}.` : 'Failed to copy.');
        }

        function updatePlanCommitButtonLabel() {
            const btn = document.getElementById('plan-commit-btn');
            if (!btn) return;
            const n = planSelectedChannelIds ? planSelectedChannelIds.size : 0;
            btn.textContent = n ? `‚úÖ Commit selected (${n})` : '‚úÖ Commit planned changes';
        }

        function setPlannedSelected(channelId, selected) {
            if (!planSelectedChannelIds) planSelectedChannelIds = new Set();
            const cid = String(channelId);
            if (!cid) return;
            if (selected) planSelectedChannelIds.add(cid);
            else planSelectedChannelIds.delete(cid);
            updatePlanCommitButtonLabel();
        }

        function clearPlannedSelection() {
            planSelectedChannelIds = new Set();
            updatePlanCommitButtonLabel();
            renderPlanRows();
        }

        function getVisiblePlanRows() {
            const q = (document.getElementById('plan-search')?.value || '').trim().toLowerCase();
            const rows = Array.isArray(planRows) ? planRows : [];
            return rows.filter((r) => {
                if (!r || typeof r !== 'object') return false;
                const label = `${r.channel_number ?? ''} ${r.channel_name ?? ''} ${r.channel_id ?? ''}`.toLowerCase();
                return !q || label.includes(q);
            });
        }

        function selectAllPlannedChannels() {
            // Select all *changed* channels currently visible under the search filter.
            const visible = getVisiblePlanRows();
            visible.forEach((r) => {
                if (r && r.changed === true && r.channel_id !== undefined && r.channel_id !== null) {
                    planSelectedChannelIds.add(String(r.channel_id));
                }
            });
            updatePlanCommitButtonLabel();
            renderPlanRows();
        }

        function renderPlanMeta() {
            const el = document.getElementById('plan-meta');
            if (!el) return;
            if (!planMeta || typeof planMeta !== 'object') {
                el.innerHTML = '';
                return;
            }
            const stats = planMeta.stats || {};
            const bits = [];
            if (planMeta.generated_at) bits.push(`<span class="pill">Generated: ${escapeHtml(fmtIso(planMeta.generated_at))}</span>`);
            if (stats.channels_total !== undefined) bits.push(`<span class="pill">Channels: ${escapeHtml(String(stats.channels_total))}</span>`);
            if (stats.total_streams_before !== undefined && stats.total_streams_after !== undefined) {
                bits.push(`<span class="pill">Total streams: ${escapeHtml(String(stats.total_streams_before))} ‚Üí ${escapeHtml(String(stats.total_streams_after))}</span>`);
            }
            if (stats.cancelled === true) bits.push(`<span class="pill" style="background:#fed7d7;color:#742a2a;">Plan job cancelled</span>`);
            el.innerHTML = bits.join(' ');
        }

        function renderPlanRows() {
            const listEl = document.getElementById('plan-list');
            if (!listEl) return;
            const filtered = getVisiblePlanRows();

            listEl.innerHTML = filtered.map((r) => {
                const channelId = r.channel_id;
                const cn = r.channel_number !== undefined && r.channel_number !== null ? `#${escapeHtml(String(r.channel_number))}` : '';
                const nm = r.channel_name ? escapeHtml(String(r.channel_name)) : '';
                const changed = r.changed === true;
                const isSelected = planSelectedChannelIds && planSelectedChannelIds.has(String(channelId));
                const beforeCount = Number.isFinite(r.before_count) ? r.before_count : (Array.isArray(r.before_stream_ids) ? r.before_stream_ids.length : 0);
                const afterCount = Number.isFinite(r.after_count) ? r.after_count : (Array.isArray(r.after_stream_ids) ? r.after_stream_ids.length : 0);
                const removedCount = Number.isFinite(r.removed_count) ? r.removed_count : (Array.isArray(r.removed_stream_ids) ? r.removed_stream_ids.length : 0);
                const addedCount = Number.isFinite(r.added_count) ? r.added_count : (Array.isArray(r.added_stream_ids) ? r.added_stream_ids.length : 0);

                const badge = changed ? `<span class="badge changed">Changed</span>` : `<span class="badge unchanged">Unchanged</span>`;
                const deltas = [
                    `<span class="pill">${escapeHtml(String(beforeCount))} ‚Üí ${escapeHtml(String(afterCount))}</span>`,
                    removedCount ? `<span class="badge removed">‚àí${escapeHtml(String(removedCount))}</span>` : '',
                    addedCount ? `<span class="badge added">+${escapeHtml(String(addedCount))}</span>` : '',
                ].filter(Boolean).join(' ');

                const providerCounts = r.after_provider_counts_preview || {};
                const providerBits = Object.entries(providerCounts).map(([pid, cnt]) => {
                    const label = escapeHtml(providerNameFromPlan(pid));
                    return `<span class="pill" title="Provider ${escapeHtml(pid)}">${label}: ${escapeHtml(String(cnt))}</span>`;
                });

                const afterPreview = Array.isArray(r.after_streams_preview) ? r.after_streams_preview : [];
                const addedPreview = Array.isArray(r.added_streams_preview) ? r.added_streams_preview : [];
                const removedPreview = Array.isArray(r.removed_streams_preview) ? r.removed_streams_preview : [];
                const beforePreview = Array.isArray(r.before_streams_preview) ? r.before_streams_preview : [];
                const limit = r.stream_preview_limit || (document.getElementById('plan-preview-limit')?.value || '60');

                return `
                    <div class="plan-card" style="margin-bottom: 12px;">
                        <div class="plan-row-title">
                            <div>
                                <div class="row" style="gap:10px; align-items:baseline;">
                                    <input type="checkbox"
                                           ${changed ? '' : 'disabled'}
                                           ${isSelected ? 'checked' : ''}
                                           onchange="setPlannedSelected('${escapeHtml(String(channelId))}', this.checked)" />
                                    <strong>${cn} ${nm}</strong>
                                </div>
                                <span class="muted small mono">(${escapeHtml(String(channelId))})</span>
                            </div>
                            <div class="plan-badges">${badge} ${deltas}</div>
                        </div>
                        ${providerBits.length ? `<div class="plan-badges" style="margin-top:8px;">${providerBits.join('')}</div>` : ''}

                        <details style="margin-top: 10px;">
                            <summary class="muted small">Preview ordered ‚Äúafter‚Äù stream list (showing first ${escapeHtml(String(limit))})</summary>
                            <div class="plan-streams">
                                ${afterPreview.length ? afterPreview.map(streamLineHtml).join('') : '<div class="muted small">No after_streams_preview available.</div>'}
                            </div>
                        </details>

                        ${(addedCount || removedCount || beforePreview.length) ? `
                            <details style="margin-top: 10px;">
                                <summary class="muted small">Changes detail</summary>
                                ${beforePreview.length ? `
                                    <div style="margin-top:10px;">
                                        <div style="font-weight:700;color:#2d3748;margin-bottom:6px;">Before (preview)</div>
                                        <div class="plan-streams">${beforePreview.map(streamLineHtml).join('')}</div>
                                    </div>
                                ` : ''}
                                ${addedPreview.length ? `
                                    <div style="margin-top:10px;">
                                        <div style="font-weight:700;color:#22543d;margin-bottom:6px;">Added (preview)</div>
                                        <div class="plan-streams">${addedPreview.map(streamLineHtml).join('')}</div>
                                    </div>
                                ` : ''}
                                ${removedPreview.length ? `
                                    <div style="margin-top:10px;">
                                        <div style="font-weight:700;color:#742a2a;margin-bottom:6px;">Removed (preview)</div>
                                        <div class="plan-streams">${removedPreview.map(streamLineHtml).join('')}</div>
                                    </div>
                                ` : ''}
                                ${(!addedPreview.length && !removedPreview.length && !beforePreview.length) ? '<div class="muted small" style="margin-top:10px;">No preview details available.</div>' : ''}
                            </details>
                        ` : ''}

                        <div class="plan-actions">
                            <button class="btn btn-sm" type="button" onclick="copyAfterIds('${escapeHtml(String(channelId))}')">Copy after_stream_ids</button>
                            <span class="muted small mono">Apply order: channel #${escapeHtml(String(r.channel_number ?? ''))}, streams in listed order</span>
                        </div>
                    </div>
                `;
            }).join('');

            if (!filtered.length) {
                listEl.innerHTML = '<div class="muted small" style="margin-top:10px;">No channels match the current filter.</div>';
            }
        }

        async function loadPlan() {
            planLoaded = true;
            const listEl = document.getElementById('plan-list');
            const changedOnlyEl = document.getElementById('plan-changed-only');
            const previewLimitEl = document.getElementById('plan-preview-limit');
            const includeBeforeEl = document.getElementById('plan-include-before');
            if (!listEl) return;

            if (!jobId) {
                setPlanStatus('Select a specific run (job_id) to view its plan.');
                setPlanCommitStatus('');
                planAvailable = false;
                setPlanCommitEnabled(false);
                planRows = [];
                planMeta = null;
                planProviderNames = {};
                planSelectedChannelIds = new Set();
                updatePlanCommitButtonLabel();
                listEl.innerHTML = '';
                setPlanCount(0);
                return;
            }

            async function fetchAndRender() {
                const changedOnly = Boolean(changedOnlyEl && changedOnlyEl.checked);
                const previewLimit = previewLimitEl ? String(previewLimitEl.value || '60') : '60';
                const includeBefore = Boolean(includeBeforeEl && includeBeforeEl.checked);
                setPlanStatus('Loading...');
                setPlanCommitStatus('');
                setPlanCommitEnabled(false);
                listEl.innerHTML = '';
                planRows = [];
                planMeta = null;
                planProviderNames = {};
                planSelectedChannelIds = new Set();
                updatePlanCommitButtonLabel();

                try {
                    const url = `/api/dispatcharr-plan/${encodeURIComponent(jobId)}?limit=2000&offset=0&changed_only=${changedOnly ? '1' : '0'}&include_details=1&stream_preview_limit=${encodeURIComponent(previewLimit)}&include_before_preview=${includeBefore ? '1' : '0'}`;
                    const resp = await fetch(url);
                    const data = await resp.json();
                    if (!data.success) {
                        setPlanStatus(data.error || 'No plan available for this run.');
                        planAvailable = false;
                        setPlanCommitEnabled(false);
                        listEl.innerHTML = '';
                        setPlanCount(0);
                        return;
                    }

                    const rows = Array.isArray(data.rows) ? data.rows : [];
                    planRows = rows;
                    planMeta = data.meta || null;
                    planProviderNames = data.provider_names || {};
                    setPlanCount(data.total || rows.length || 0);
                    renderPlanMeta();
                    renderPlanRows();
                    setPlanStatus(rows.length ? `Loaded ${rows.length} channel(s).` : 'No planned changes.');
                    planAvailable = rows.some((r) => r && typeof r === 'object' && r.changed === true);
                    setPlanCommitEnabled(planAvailable);
                    updatePlanCommitButtonLabel();
                } catch (e) {
                    setPlanStatus(`Failed to load plan: ${e.message}`);
                    listEl.innerHTML = '';
                    setPlanCount(0);
                }
            }

            if (changedOnlyEl) {
                changedOnlyEl.addEventListener('change', fetchAndRender);
            }
            if (previewLimitEl) {
                previewLimitEl.addEventListener('change', fetchAndRender);
            }
            if (includeBeforeEl) {
                includeBeforeEl.addEventListener('change', fetchAndRender);
            }
            await fetchAndRender();
        }

        async function commitPlan() {
            if (!jobId) {
                setPlanCommitStatus('Select a specific run first.');
                return;
            }
            if (!planAvailable) {
                setPlanCommitStatus('No planned changes to commit.');
                return;
            }

            const selected = planSelectedChannelIds ? Array.from(planSelectedChannelIds) : [];
            const ok = window.confirm(
                `This will UPDATE Dispatcharr channel stream lists to match the plan for this run.\n\n` +
                (selected.length ? `Selected channels: ${selected.length}\n\n` : '') +
                'Continue?'
            );
            if (!ok) return;

            setPlanCommitStatus('Committing...');
            setPlanCommitEnabled(false);

            try {
                const resp = await fetch(`/api/dispatcharr-plan/${encodeURIComponent(jobId)}/commit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ confirm: true, changed_only: true, channel_ids: selected.length ? selected : null })
                });
                const data = await resp.json();
                if (!data.success) {
                    setPlanCommitStatus(data.error || 'Failed to commit planned changes.');
                    setPlanCommitEnabled(true);
                    return;
                }

                const applied = typeof data.applied_channels === 'number' ? data.applied_channels : 0;
                const failed = typeof data.failed_channels === 'number' ? data.failed_channels : 0;
                setPlanCommitStatus(`Committed ${applied} channel(s)${failed ? ` (${failed} failed)` : ''}.`);

                // Refresh the plan view (still reflects the same saved plan file).
                planLoaded = false;
                await loadPlan();
            } catch (e) {
                setPlanCommitStatus(`Commit failed: ${e.message}`);
                setPlanCommitEnabled(true);
            }
        }

        function filterStreamRows() {
            const q = (document.getElementById('stream-search')?.value || '').trim().toLowerCase();
            document.querySelectorAll('.stream-row').forEach((row) => {
                const name = row.getAttribute('data-stream-name') || '';
                row.style.display = (!q || name.includes(q)) ? '' : 'none';
            });
            updateStreamsCount();
        }

        function selectAllStreams() {
            document.querySelectorAll('.stream-row input[type="checkbox"]').forEach(cb => { cb.checked = true; });
            updateStreamsCount();
        }

        function clearAllStreams() {
            document.querySelectorAll('.stream-row input[type="checkbox"]').forEach(cb => { cb.checked = false; });
            updateStreamsCount();
        }

        function getStreamIncludeExclude() {
            const include = [];
            const exclude = [];
            document.querySelectorAll('.stream-row').forEach((row) => {
                const name = row.querySelector('td:nth-child(2)')?.innerText?.trim() || '';
                const checked = row.querySelector('input[type="checkbox"]')?.checked;
                if (!name) return;
                if (checked) include.push(name);
                else exclude.push(name);
            });
            return { include, exclude };
        }

        async function generateStreamRegex() {
            setStreamStatus('Generating...');
            const { include, exclude } = getStreamIncludeExclude();
            const outBox = document.getElementById('stream-regex-output');
            const outCode = document.getElementById('stream-regex-code');
            const copyBtn = document.getElementById('copy-stream-regex-btn');

            if (!include.length) {
                setStreamStatus('Select at least one stream.');
                if (outBox) outBox.style.display = 'none';
                if (copyBtn) copyBtn.disabled = true;
                return;
            }

            try {
                const resp = await fetch('/api/regex/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ include, exclude })
                });
                const data = await resp.json();
                if (!data.success) {
                    setStreamStatus(data.error || 'Failed to generate regex.');
                    if (outBox) outBox.style.display = 'none';
                    if (copyBtn) copyBtn.disabled = true;
                    return;
                }
                const regex = data.regex || '';
                if (outCode) outCode.textContent = regex;
                if (outBox) outBox.style.display = 'block';
                if (copyBtn) copyBtn.disabled = !regex;
                setStreamStatus(`Suggested regex ready. Includes: ${include.length}, excludes: ${exclude.length}.`);
            } catch (e) {
                setStreamStatus(`Failed: ${e.message}`);
                if (outBox) outBox.style.display = 'none';
                if (copyBtn) copyBtn.disabled = true;
            }
        }

        async function copyStreamRegex() {
            const regexText = document.getElementById('stream-regex-code')?.textContent || '';
            if (!regexText) return;
            try {
                await navigator.clipboard.writeText(regexText);
                setStreamStatus('Copied regex to clipboard.');
            } catch {
                const ta = document.createElement('textarea');
                ta.value = regexText;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                setStreamStatus('Copied regex to clipboard.');
            }
        }
    </script>
</body>
</html>
