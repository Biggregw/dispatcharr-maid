<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Results - Dispatcharr Maid</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='logo.svg') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='brand.css') }}">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto; background: var(--app-bg); min-height: 100vh; padding: 20px; color: var(--text-primary); }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { text-align: center; color: var(--text-primary); margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; color: var(--accent-strong); text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.9); }
        .nav-buttons { text-align: center; margin-bottom: 20px; }
        .btn { padding: 12px 30px; border: none; border-radius: 12px; font-size: 1em; font-weight: 700; cursor: pointer; background: var(--surface-raised); color: var(--accent-strong); margin: 0 10px; transition: all 0.3s; text-decoration: none; display: inline-block; box-shadow: var(--shadow-soft); }
        .btn:hover { transform: translateY(-2px); box-shadow: var(--shadow-raised); }
        .card { background: var(--surface-raised); border-radius: 18px; padding: 25px; margin-bottom: 20px; box-shadow: var(--shadow-raised); }
        .card h2 { color: var(--accent-strong); margin-bottom: 20px; font-size: 1.5em; border-bottom: 1px solid rgba(86, 70, 194, 0.2); padding-bottom: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-box { background: var(--surface-inset); padding: 20px; border-radius: 14px; box-shadow: var(--shadow-inset); }
        .stat-label { color: var(--text-muted); font-size: 0.9em; margin-bottom: 5px; }
        .stat-value { font-size: 2em; font-weight: 700; color: var(--text-primary); }
        .stat-value.success { color: var(--success); }
        .stat-value.failed { color: var(--danger); }
        table { width: 100%; border-collapse: separate; border-spacing: 0 10px; margin: 20px 0; }
        th, td { padding: 12px 14px; text-align: left; border: none; }
        th { background: transparent; color: var(--text-muted); font-weight: 700; }
        tbody tr { box-shadow: var(--shadow-soft); border-radius: 12px; }
        tbody td { background: var(--surface-raised); }
        tbody tr td:first-child { border-top-left-radius: 12px; border-bottom-left-radius: 12px; }
        tbody tr td:last-child { border-top-right-radius: 12px; border-bottom-right-radius: 12px; }
        tr:hover td { background: var(--surface); }
        .success-badge { display: inline-block; padding: 4px 12px; border-radius: 999px; font-size: 0.85em; font-weight: 700; box-shadow: var(--shadow-soft); }
        .success-badge.excellent { background: var(--success-soft); color: var(--success); }
        .success-badge.good { background: rgba(107, 91, 209, 0.12); color: var(--accent-strong); }
        .success-badge.fair { background: var(--warning-soft); color: var(--warning); }
        .success-badge.poor { background: var(--danger-soft); color: var(--danger); }
        .capacity-warning { margin-top: 12px; color: var(--warning); font-weight: 700; }
        .muted { color: var(--text-muted); }
        .small { font-size: 0.9em; }
        .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background: var(--surface-inset); color: var(--text-primary); font-weight: 600; font-size: 0.85em; box-shadow: var(--shadow-inset); }
        .btn-sm { padding: 10px 14px; border-radius: 10px; font-size: 0.95em; }
        .input { width: 100%; padding: 10px 12px; border: none; border-radius: 10px; font-size: 1em; background: var(--surface-inset); color: var(--text-primary); box-shadow: var(--shadow-inset); }
        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
        code { word-break: break-word; }
        .stream-table-wrap { overflow-x: auto; background: var(--surface-inset); border-radius: 16px; box-shadow: var(--shadow-inset); padding: 6px; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brand">
                <img class="brand-logo" src="{{ url_for('static', filename='logo.svg') }}" alt="Dispatcharr Maid">
                <div class="brand-text">
                    <h1>Analysis Results</h1>
                    <p>Detailed Stream Quality Report</p>
                </div>
            </div>
        </div>
        
        <div class="nav-buttons">
            <a href="/" class="btn">‚Üê Back to Control Panel</a>
            <a href="/api/results/csv" class="btn" id="export-csv-link">üì• Export CSV</a>
            <span class="muted" style="display:inline-block;font-weight:600;margin-left:10px;">Run:</span>
            <select id="job-picker" class="input" style="display:inline-block; width:auto; min-width: 320px; max-width: 520px; margin-left:8px;"></select>
        </div>
        
        <div class="card">
            <h2>üìà Overall Summary</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Total Streams Analyzed</div>
                    <div class="stat-value" id="stat-total">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Successful</div>
                    <div class="stat-value success" id="stat-success">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value failed" id="stat-failed">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="stat-rate">0%</div>
                </div>
            </div>
            <div id="capacity-warning" class="capacity-warning" style="display:none;"></div>
        </div>

        <div class="card" id="ordering-visibility-card" style="display:none;">
            <h2>‚úÖ Final Channel Stream Order</h2>
            <div class="muted small">Displays the exact order written back to Dispatcharr and the streams that were excluded with their reasons.</div>
            <div class="stream-table-wrap">
                <table id="final-order-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>#</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Codec</th>
                            <th>Bitrate</th>
                            <th>Validation</th>
                            <th>Final Score</th>
                        </tr>
                    </thead>
                    <tbody id="final-order-tbody"></tbody>
                </table>
            </div>

            <h3 style="margin-top: 20px;">üö´ Excluded Streams</h3>
            <div class="stream-table-wrap">
                <table id="excluded-stream-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                            <th>Reason</th>
                        </tr>
                    </thead>
                    <tbody id="excluded-stream-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="refresh-breakdown-card" style="display:none;">
            <h2>üîÑ Refresh Stream Changes</h2>
            <div class="muted small">Comparison of the channel before and after refresh. Status is derived from the original list and the final replacement list.</div>
            <div class="stream-table-wrap">
                <table id="refresh-change-table">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                        </tr>
                    </thead>
                    <tbody id="refresh-change-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="run-meta-card" style="display:none;">
            <h2>üßæ Run Details</h2>
            <div id="run-meta-body" class="muted small"></div>
        </div>
    </div>

    <script>
        const params = new URLSearchParams(window.location.search);
        const jobId = params.get('job_id');
        const resultsUrl = jobId ? `/api/results/job/${encodeURIComponent(jobId)}` : '/api/results/detailed';
        // Populated from the detailed results payload; reused by the ordering tables.
        let providerNames = {};

        function escapeHtml(str) {
            const s = String(str ?? '');
            return s.replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[c]));
        }

        function showWarning(title, message) {
            document.body.innerHTML = `
                <div style="text-align:center;padding:40px;color:var(--text-primary);">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <a href="/" style="color:var(--accent-strong);">Go Back</a>
                </div>
            `;
        }

        function providerLabelHtml(providerId) {
            if ((providerId ?? '') === '') return '';
            const pid = String(providerId);
            const label = Object.prototype.hasOwnProperty.call(providerNames, pid)
                ? providerNames[pid]
                : `Provider ${pid}`;
            return `<span title="Provider ${escapeHtml(pid)}">${escapeHtml(String(label))}</span>`;
        }

        function setExportLink() {
            const link = document.getElementById('export-csv-link');
            if (!link) return;
            link.href = jobId ? `/api/results/csv?job_id=${encodeURIComponent(jobId)}` : '/api/results/csv';
        }

        function fmtIso(iso) {
            if (!iso) return '';
            try {
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return String(iso);
                return d.toLocaleString();
            } catch {
                return String(iso);
            }
        }

        function fmtBitrate(kbps) {
            if (kbps === null || kbps === undefined || kbps === 'N/A') return '‚Äî';
            const num = Number(kbps);
            if (Number.isNaN(num)) return escapeHtml(String(kbps));
            return `${num.toLocaleString()} kbps`;
        }

        function channelLabelFrom(row) {
            if (!row || typeof row !== 'object') return 'Unknown channel';
            const labelRow = {
                channel_number: row.channel_number,
                channel_name: row.channel_name,
                channel_id: row.channel_id
            };
            return fmtChannelLabel(labelRow);
        }

        function renderJobMeta(meta) {
            const card = document.getElementById('run-meta-card');
            const body = document.getElementById('run-meta-body');
            if (!card || !body) return;
            if (!meta || typeof meta !== 'object') {
                card.style.display = 'none';
                body.innerHTML = '';
                return;
            }

            const selection = meta.selection || {};
            const groupIds = Array.isArray(selection.channel_group_ids) ? selection.channel_group_ids : [];
            const channelIds = Array.isArray(selection.specific_channel_ids) ? selection.specific_channel_ids : [];
            const nameRegex = selection.channel_name_regex || '';
            const numRegex = selection.channel_number_regex || '';
            const selectionLines = [];
            if (groupIds.length) selectionLines.push(`<div><strong>Groups (config)</strong>: ${escapeHtml(groupIds.join(', '))}</div>`);
            if (channelIds.length) selectionLines.push(`<div><strong>Specific channels (config)</strong>: ${escapeHtml(channelIds.slice(0, 50).join(', '))}${channelIds.length > 50 ? '‚Ä¶' : ''}</div>`);
            if (meta.job_type !== 'refresh') {
                if (nameRegex) selectionLines.push(`<div><strong>Channel name regex</strong>: <code>${escapeHtml(nameRegex)}</code></div>`);
                if (numRegex) selectionLines.push(`<div><strong>Channel number regex</strong>: <code>${escapeHtml(numRegex)}</code></div>`);
            }

            const chosen = [];
            if (meta.group_names) chosen.push(`<div><strong>Selected</strong>: ${escapeHtml(String(meta.group_names))}${meta.channel_names ? ` ‚Äî ${escapeHtml(String(meta.channel_names))}` : ''}</div>`);
            if (meta.selection_pattern_name) chosen.push(`<div><strong>Pattern</strong>: ${escapeHtml(String(meta.selection_pattern_name))}</div>`);

            const runLines = [
                `<div><strong>Job</strong>: ${escapeHtml(String(meta.job_id || 'latest'))}</div>`,
                meta.job_type ? `<div><strong>Type</strong>: ${escapeHtml(String(meta.job_type))}</div>` : '',
                meta.status ? `<div><strong>Status</strong>: ${escapeHtml(String(meta.status))}</div>` : '',
                meta.started_at ? `<div><strong>Started</strong>: ${escapeHtml(fmtIso(meta.started_at))}</div>` : '',
                meta.completed_at ? `<div><strong>Completed</strong>: ${escapeHtml(fmtIso(meta.completed_at))}</div>` : '',
                meta.config_hash ? `<div><strong>Config hash</strong>: <code>${escapeHtml(String(meta.config_hash))}</code></div>` : '',
            ].filter(Boolean);

            const refreshLines = [];
            if (meta.base_search_text) refreshLines.push(`<div><strong>Literal search text</strong>: ${escapeHtml(String(meta.base_search_text))}</div>`);

            const sections = []
                .concat(chosen.length ? [`<div style="margin-bottom:10px;">${chosen.join('')}</div>`] : [])
                .concat(runLines.length ? [`<div style="margin-bottom:10px;">${runLines.join('')}</div>`] : [])
                .concat(selectionLines.length ? [`<div style="margin-bottom:10px;">${selectionLines.join('')}</div>`] : [])
                .concat(refreshLines.length ? [`<div>${refreshLines.join('')}</div>`] : []);

            body.innerHTML = sections.length ? sections.join('') : '<div class="muted">No run metadata available.</div>';
            card.style.display = '';
        }

        async function loadJobPicker() {
            const picker = document.getElementById('job-picker');
            if (!picker) return;

            // Default option (no job_id => latest)
            picker.innerHTML = `<option value="">Latest</option>`;

            try {
                const resp = await fetch('/api/job-history');
                const data = await resp.json();
                const history = (data && data.success && Array.isArray(data.history)) ? data.history : [];

                // Only show completed jobs first (others can appear but won't have stable results).
                const completed = history.filter(j => j && typeof j === 'object' && j.status === 'completed');
                completed.forEach((j) => {
                    const id = j.job_id;
                    if (!id) return;
                    const started = fmtIso(j.started_at);
                    const typ = j.job_type || 'job';
                    const sel = (j.group_names || '').toString();
                    const label = `${started} ‚Äî ${typ}${sel ? ` ‚Äî ${sel}` : ''}`.trim();
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = label;
                    picker.appendChild(opt);
                });
            } catch {
                // ignore picker load failures; page still works
            }

            // Select current job.
            picker.value = jobId || '';
            picker.addEventListener('change', (e) => {
                const v = e.target && e.target.value ? String(e.target.value) : '';
                window.location.href = v ? `/results?job_id=${encodeURIComponent(v)}` : '/results';
            });
        }

        setExportLink();
        loadJobPicker();

        function refreshStreamProviderLabels() {
            document.querySelectorAll('#stream-tbody .stream-row').forEach((row) => {
                const pid = row.getAttribute('data-provider-id') || '';
                const cell = row.querySelector('td:nth-child(6)');
                if (cell) cell.innerHTML = providerLabelHtml(pid);
            });
        }

        function renderRefreshBreakdown(summary) {
            const card = document.getElementById('refresh-breakdown-card');
            const tbody = document.getElementById('refresh-change-tbody');
            if (!card || !tbody) return;

            const previous = Array.isArray(summary?.previous_streams) ? summary.previous_streams : [];
            const finalStreams = Array.isArray(summary?.final_streams)
                ? summary.final_streams
                : (Array.isArray(summary?.streams) ? summary.streams : []);

            const finalIds = new Set(finalStreams.map((s) => String(s?.id ?? s?.stream_id ?? '')));
            const previousIds = new Set(previous.map((s) => String(s?.id ?? s?.stream_id ?? '')));

            const rows = [];

            finalStreams.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                const status = previousIds.has(id) ? 'Kept' : 'Added';
                rows.push({ ...s, status });
            });

            previous.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                if (!finalIds.has(id)) {
                    rows.push({ ...s, status: 'Removed' });
                }
            });

            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="5" class="muted">No stream details available for this refresh.</td></tr>';
                card.style.display = '';
                return;
            }

            tbody.innerHTML = rows.map((row) => {
                const name = row?.name || row?.stream_name || `Stream ${row?.id ?? ''}`;
                const pid = row?.provider_id ?? row?.providerid ?? row?.provider;
                const providerCell = providerLabelHtml(pid ?? row?.provider_name) || escapeHtml(row?.provider_name || '');
                const resolution = escapeHtml(row?.resolution || '‚Äî');
                const bitrate = fmtBitrate(row?.bitrate_kbps);
                const statusClass = row.status === 'Removed' ? 'badge removed' : (row.status === 'Added' ? 'badge added' : 'badge unchanged');
                return `
                    <tr>
                        <td><span class="${statusClass}">${escapeHtml(row.status || '')}</span></td>
                        <td>${escapeHtml(String(name))}</td>
                        <td>${providerCell}</td>
                        <td>${resolution}</td>
                        <td>${bitrate}</td>
                    </tr>
                `;
            }).join('');

            card.style.display = '';
        }

        function renderOrderingTables(ordering) {
            const card = document.getElementById('ordering-visibility-card');
            if (!card) return;
            const finalBody = document.getElementById('final-order-tbody');
            const excludedBody = document.getElementById('excluded-stream-tbody');
            if (!finalBody || !excludedBody) return;

            const finalOrders = Array.isArray(ordering?.final_orders) ? ordering.final_orders : [];
            const excluded = Array.isArray(ordering?.excluded_streams) ? ordering.excluded_streams : [];

            if (!finalOrders.length && !excluded.length) {
                card.style.display = 'none';
                return;
            }

            const sortedFinal = [...finalOrders].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const orderA = Number(a?.order ?? 0);
                const orderB = Number(b?.order ?? 0);
                return orderA - orderB;
            });

            finalBody.innerHTML = sortedFinal.map((row) => {
                const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                const validation = row?.validation_result ? escapeHtml(String(row.validation_result)) : '‚Äî';
                const score = row?.final_score;
                const scoreText = score === null || score === undefined ? '‚Äî' : escapeHtml(Number(score).toFixed ? Number(score).toFixed(1) : String(score));
                return `
                    <tr>
                        <td>${channelLabelFrom(row)}</td>
                        <td class="mono">${escapeHtml(row?.order ?? '')}</td>
                        <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                        <td>${providerCell}</td>
                        <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                        <td>${escapeHtml(row?.video_codec || '‚Äî')}</td>
                        <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                        <td>${validation}</td>
                        <td>${scoreText}</td>
                    </tr>
                `;
            }).join('');

            const sortedExcluded = [...excluded].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const nameA = (a?.stream_name || '').toString().toLowerCase();
                const nameB = (b?.stream_name || '').toString().toLowerCase();
                return nameA.localeCompare(nameB);
            });

            excludedBody.innerHTML = sortedExcluded.map((row) => {
                const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                return `
                    <tr>
                        <td>${channelLabelFrom(row)}</td>
                        <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                        <td>${providerCell}</td>
                        <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                        <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                        <td>${escapeHtml(row?.reason || '‚Äî')}</td>
                    </tr>
                `;
            }).join('');

            if (!excluded.length) {
                excludedBody.innerHTML = '<tr><td colspan="6" class="muted">No streams were excluded.</td></tr>';
            }

            card.style.display = '';
        }

        fetch(resultsUrl)
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.body.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text-primary);"><h2>No results available</h2><p>Run an analysis first.</p><a href="/" style="color:var(--accent-strong);">Go Back</a></div>';
                    return;
                }
                
                const r = data.results;
                providerNames = data.provider_names || {};
                renderJobMeta(data.job_meta || null);
                const jobType = r.job_type || data.job_type;
                const analyzedStreams = typeof data.analyzed_streams === 'number'
                    ? data.analyzed_streams
                    : (typeof r.total === 'number' ? r.total : 0);
                
                // Check if this is a refresh job
                if (jobType === 'refresh') {
                    // Show refresh-specific results
                    document.querySelector('.header h1').textContent = 'üîÑ Channel Refresh Results';
                    document.querySelector('.header p').textContent = 'Stream Replacement Summary';
                    
                    document.getElementById('stat-total').textContent = r.total_matching.toLocaleString();
                    document.querySelector('#stat-total').previousElementSibling.textContent = 'Total Matching Streams Found';
                    
                    document.getElementById('stat-success').textContent = (r.added || 0).toLocaleString();
                    document.querySelector('#stat-success').previousElementSibling.textContent = 'Streams Added';
                    
                    document.getElementById('stat-failed').textContent = (r.removed || 0).toLocaleString();
                    document.querySelector('#stat-failed').previousElementSibling.textContent = 'Streams Removed';
                    document.querySelector('#stat-failed').classList.remove('failed');
                    document.querySelector('#stat-failed').style.color = '#718096';
                    
                    document.getElementById('stat-rate').textContent = 'Refresh Complete';
                    document.querySelector('#stat-rate').previousElementSibling.textContent = 'Status';
                    
                    renderRefreshBreakdown(r);

                    return;
                }

                if (data.analysis_ran === false) {
                    showWarning('No analysis ran for this job', 'This job did not execute stream analysis.');
                    return;
                }

                if (analyzedStreams === 0) {
                    showWarning('No analysis results', 'Stream analysis ran but produced zero analyzed streams.');
                    return;
                }
                
                // Otherwise, show analysis results
                document.getElementById('stat-total').textContent = r.total.toLocaleString();
                document.getElementById('stat-success').textContent = r.successful.toLocaleString();
                document.getElementById('stat-failed').textContent = r.failed.toLocaleString();
                document.getElementById('stat-rate').textContent = r.success_rate + '%';
                const capacitySummary = r.capacity_summary || data.capacity_summary;
                if (capacitySummary && capacitySummary.warning) {
                    const capacityEl = document.getElementById('capacity-warning');
                    capacityEl.textContent = capacitySummary.warning;
                    capacityEl.style.display = 'block';
                }

                const orderingVisibility = data.ordering_visibility || r.ordering_visibility;
                renderOrderingTables(orderingVisibility);
            })
            .catch(err => {
                console.error('Failed to load results:', err);
                showWarning('Failed to load results', 'An error occurred while loading the analysis results.');
            });
        function fmtChannelLabel(row) {
            const num = row && row.channel_number !== undefined && row.channel_number !== null ? String(row.channel_number) : '';
            const name = row && row.channel_name ? String(row.channel_name) : '';
            const id = row && row.channel_id !== undefined && row.channel_id !== null ? String(row.channel_id) : '';
            if (num && name) return `#${escapeHtml(num)} ${escapeHtml(name)} (id ${escapeHtml(id)})`;
            if (name) return `${escapeHtml(name)} (id ${escapeHtml(id)})`;
            return `Channel ${escapeHtml(id)}`;
        }
    </script>
</body>
</html>
