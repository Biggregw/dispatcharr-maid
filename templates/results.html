<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Results - Dispatcharr Maid</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='logo.svg') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='brand.css') }}">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .nav-buttons { text-align: center; margin-bottom: 20px; }
        .btn { padding: 12px 30px; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; background: white; color: #667eea; margin: 0 10px; transition: all 0.3s; text-decoration: none; display: inline-block; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .card { background: white; border-radius: 15px; padding: 25px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; border-bottom: 2px solid #667eea; padding-bottom: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-box { background: #f7fafc; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; }
        .stat-label { color: #718096; font-size: 0.9em; margin-bottom: 5px; }
        .stat-value { font-size: 2em; font-weight: bold; color: #2d3748; }
        .stat-value.success { color: #38a169; }
        .stat-value.failed { color: #e53e3e; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #eef2ff; color: #667eea; font-weight: 600; }
        tr:hover { background: #f7fafc; }
        .success-badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.9em; font-weight: 600; }
        .success-badge.excellent { background: #c6f6d5; color: #22543d; }
        .success-badge.good { background: #bee3f8; color: #2c5282; }
        .success-badge.fair { background: #feebc8; color: #7c2d12; }
        .success-badge.poor { background: #fed7d7; color: #742a2a; }
        .capacity-warning { margin-top: 12px; color: #97266d; font-weight: 600; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; }
        .tab { padding: 12px 24px; cursor: pointer; border: none; background: none; font-size: 1em; font-weight: 600; color: #718096; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .muted { color: #718096; }
        .small { font-size: 0.9em; }
        .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background: #edf2f7; color:#2d3748; font-weight: 600; font-size: 0.85em; }
        .btn-sm { padding: 10px 14px; border-radius: 8px; font-size: 0.95em; }
        .input { width: 100%; padding: 10px 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 1em; }
        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
        .stream-tools { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
        .codebox { margin-top: 10px; padding: 12px; background: #f7fafc; border-radius: 10px; border: 1px solid #e2e8f0; }
        code { word-break: break-word; }
        .stream-table-wrap { overflow-x: auto; }
        .plan-meta { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-top:10px; color:#4a5568; }
        .plan-meta .pill { background:#eef2ff; color:#3730a3; }
        .plan-card { border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px; background: #fbfdff; }
        .plan-row-title { display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:baseline; }
        .plan-row-title strong { color:#2d3748; }
        .plan-badges { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .badge { display:inline-block; padding: 3px 10px; border-radius: 999px; font-weight: 700; font-size: 0.82em; }
        .badge.changed { background:#fefcbf; color:#744210; }
        .badge.unchanged { background:#edf2f7; color:#4a5568; }
        .badge.added { background:#c6f6d5; color:#22543d; }
        .badge.removed { background:#fed7d7; color:#742a2a; }
        .plan-streams { margin-top: 10px; display:grid; grid-template-columns: 1fr; gap: 8px; }
        .plan-stream { padding: 8px 10px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 10px; }
        .plan-stream-line { display:flex; gap:8px; flex-wrap:wrap; align-items:baseline; }
        .plan-stream-line .muted { color:#718096; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        details summary { cursor: pointer; }
        .plan-actions { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
        .explanation-block { border: 1px solid #e2e8f0; border-radius: 12px; padding: 12px 14px; background: #fbfdff; margin-top: 12px; }
        .explanation-block h3 { margin-bottom: 8px; font-size: 1.05em; color: #2d3748; }
        .explanation-block ul { margin: 0 0 0 18px; }
        .explanation-block li { margin-bottom: 6px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brand">
                <img class="brand-logo" src="{{ url_for('static', filename='logo.svg') }}" alt="Dispatcharr Maid">
                <div class="brand-text">
                    <h1>Analysis Results</h1>
                    <p>Detailed Stream Quality Report</p>
                </div>
            </div>
        </div>
        
        <div class="nav-buttons">
            <a href="/" class="btn">‚Üê Back to Control Panel</a>
            <a href="/api/results/csv" class="btn" id="export-csv-link">üì• Export CSV</a>
            <button type="button" class="quality-insight-trigger" id="quality-insight-open">
                <span class="quality-insight-status quality-insight-status-{{ quality_insight_status|default('green') }}" aria-hidden="true"></span>
                Quality insight
            </button>
            <span style="display:inline-block;color:white;font-weight:600;margin-left:10px;">Run:</span>
            <select id="job-picker" class="input" style="display:inline-block; width:auto; min-width: 320px; max-width: 520px; margin-left:8px;"></select>
        </div>
        
        <div class="card">
            <h2>üìà Overall Summary</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Total Streams Analyzed</div>
                    <div class="stat-value" id="stat-total">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Successful</div>
                    <div class="stat-value success" id="stat-success">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value failed" id="stat-failed">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="stat-rate">0%</div>
                </div>
            </div>
            <div id="capacity-warning" class="capacity-warning" style="display:none;"></div>
        </div>

        <div class="card" id="ordering-visibility-card" style="display:none;">
            <h2>‚úÖ Final Channel Stream Order</h2>
            <div class="muted small">Displays the exact order written back to Dispatcharr and the streams that were excluded with their reasons.</div>
            <div class="stream-table-wrap">
                <table id="final-order-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>#</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Resolution</th>
                            <th>Codec</th>
                            <th>Bitrate</th>
                            <th>Validation</th>
                        </tr>
                    </thead>
                    <tbody id="final-order-tbody"></tbody>
                </table>
            </div>

            <h3 style="margin-top: 20px;">üö´ Excluded Streams</h3>
            <div class="stream-table-wrap">
                <table id="excluded-stream-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Service Name</th>
                            <th>Service Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                            <th>Reason</th>
                        </tr>
                    </thead>
                    <tbody id="excluded-stream-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="ordering-explanation-card">
            <h2>Why streams were ordered this way</h2>
            <div class="muted small">This explanation will appear after analysis completes.</div>
        </div>

        <div class="card" id="refresh-breakdown-card" style="display:none;">
            <h2>üîÑ Refresh Stream Changes</h2>
            <div class="muted small">Comparison of the channel before and after refresh. Status is derived from the original list and the final replacement list.</div>
            <div class="stream-table-wrap">
                <table id="refresh-change-table">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Stream</th>
                            <th>Provider</th>
                            <th>Service Name</th>
                            <th>Service Provider</th>
                            <th>Resolution</th>
                            <th>Bitrate</th>
                        </tr>
                    </thead>
                    <tbody id="refresh-change-tbody"></tbody>
                </table>
            </div>
        </div>

        <div class="card" id="run-meta-card" style="display:none;">
            <h2>üßæ Run Details</h2>
            <div id="run-meta-body" class="muted small"></div>
        </div>
    </div>

    <div class="quality-insight-modal" id="quality-insight-modal" aria-hidden="true">
        <div class="quality-insight-backdrop" data-quality-insight-close></div>
        <div class="quality-insight-dialog" role="dialog" aria-modal="true" aria-labelledby="quality-insight-title">
            <div class="quality-insight-header">
                <h2 id="quality-insight-title">Quality insight</h2>
                <button type="button" class="quality-insight-close" data-quality-insight-close aria-label="Close">
                    √ó
                </button>
            </div>
            <div class="quality-insight-body">
                <div class="quality-insight-loading">Loading‚Ä¶</div>
                <div class="quality-insight-empty quality-insight-hidden">
                    No quality insight data in the last 7 days.
                </div>
                <div class="quality-insight-error quality-insight-hidden"></div>
                <div class="quality-insight-list"></div>
            </div>
        </div>
    </div>
    <script src="{{ url_for('static', filename='quality_insight.js') }}"></script>
    <script>
        const params = new URLSearchParams(window.location.search);
        const jobId = params.get('job_id');
        const resultsUrl = jobId ? `/api/results/job/${encodeURIComponent(jobId)}` : '/api/results/detailed';
        // Populated from the detailed results payload.
        let providerNames = {};

        function escapeHtml(str) {
            const s = String(str ?? '');
            return s.replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[c]));
        }

        function showWarning(title, message) {
            document.body.innerHTML = `
                <div style="text-align:center;padding:40px;color:white;">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <a href="/" style="color:white;">Go Back</a>
                </div>
            `;
        }

        function providerLabelHtml(providerId) {
            if ((providerId ?? '') === '') return '';
            const pid = String(providerId);
            const label = Object.prototype.hasOwnProperty.call(providerNames, pid)
                ? providerNames[pid]
                : `Provider ${pid}`;
            return `<span title="Provider ${escapeHtml(pid)}">${escapeHtml(String(label))}</span>`;
        }

        function setExportLink() {
            const link = document.getElementById('export-csv-link');
            if (!link) return;
            link.href = jobId ? `/api/results/csv?job_id=${encodeURIComponent(jobId)}` : '/api/results/csv';
        }

        function fmtIso(iso) {
            if (!iso) return '';
            try {
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return String(iso);
                return d.toLocaleString();
            } catch {
                return String(iso);
            }
        }

        function fmtBitrate(kbps) {
            if (kbps === null || kbps === undefined || kbps === 'N/A') return '‚Äî';
            const num = Number(kbps);
            if (Number.isNaN(num)) return escapeHtml(String(kbps));
            return `${num.toLocaleString()} kbps`;
        }

        function fmtChannelLabel(row) {
            if (!row || typeof row !== 'object') return 'Unknown channel';
            const number = row.channel_number ?? row.channel_num ?? row.number;
            const name = row.channel_name ?? row.name;
            const id = row.channel_id ?? row.id;
            const numberText = (number === null || number === undefined || number === '') ? '' : String(number);
            const nameText = name ? String(name) : '';
            let label = '';
            if (numberText && nameText) {
                label = `${numberText} - ${nameText}`;
            } else if (numberText) {
                label = `Channel ${numberText}`;
            } else if (nameText) {
                label = nameText;
            } else if (id !== null && id !== undefined && id !== '') {
                label = `Channel ${id}`;
            } else {
                label = 'Unknown channel';
            }
            return escapeHtml(label);
        }

        function channelLabelFrom(row) {
            if (!row || typeof row !== 'object') return 'Unknown channel';
            const labelRow = {
                channel_number: row.channel_number,
                channel_name: row.channel_name,
                channel_id: row.channel_id
            };
            return fmtChannelLabel(labelRow);
        }

        function renderJobMeta(meta) {
            const card = document.getElementById('run-meta-card');
            const body = document.getElementById('run-meta-body');
            if (!card || !body) return;
            if (!meta || typeof meta !== 'object') {
                card.style.display = 'none';
                body.innerHTML = '';
                return;
            }

            const selection = meta.selection || {};
            const groupIds = Array.isArray(selection.channel_group_ids) ? selection.channel_group_ids : [];
            const channelIds = Array.isArray(selection.specific_channel_ids) ? selection.specific_channel_ids : [];
            const selectionLines = [];
            if (groupIds.length) selectionLines.push(`<div><strong>Groups (config)</strong>: ${escapeHtml(groupIds.join(', '))}</div>`);
            if (channelIds.length) selectionLines.push(`<div><strong>Specific channels (config)</strong>: ${escapeHtml(channelIds.slice(0, 50).join(', '))}${channelIds.length > 50 ? '‚Ä¶' : ''}</div>`);

            const chosen = [];
            if (meta.group_names) chosen.push(`<div><strong>Selected</strong>: ${escapeHtml(String(meta.group_names))}${meta.channel_names ? ` ‚Äî ${escapeHtml(String(meta.channel_names))}` : ''}</div>`);
            if (meta.selection_pattern_name) chosen.push(`<div><strong>Pattern</strong>: ${escapeHtml(String(meta.selection_pattern_name))}</div>`);

            const runLines = [
                `<div><strong>Job</strong>: ${escapeHtml(String(meta.job_id || 'latest'))}</div>`,
                meta.job_type ? `<div><strong>Type</strong>: ${escapeHtml(String(meta.job_type))}</div>` : '',
                meta.status ? `<div><strong>Status</strong>: ${escapeHtml(String(meta.status))}</div>` : '',
                meta.started_at ? `<div><strong>Started</strong>: ${escapeHtml(fmtIso(meta.started_at))}</div>` : '',
                meta.completed_at ? `<div><strong>Completed</strong>: ${escapeHtml(fmtIso(meta.completed_at))}</div>` : '',
                meta.config_hash ? `<div><strong>Config hash</strong>: <code>${escapeHtml(String(meta.config_hash))}</code></div>` : '',
            ].filter(Boolean);

            const refreshLines = [];
            if (meta.base_search_text) refreshLines.push(`<div><strong>Primary Match</strong>: ${escapeHtml(String(meta.base_search_text))}</div>`);
            if (meta.include_filter) refreshLines.push(`<div><strong>Include filter</strong>: ${escapeHtml(String(meta.include_filter))}</div>`);
            if (meta.exclude_filter) refreshLines.push(`<div><strong>Exclude filter</strong>: ${escapeHtml(String(meta.exclude_filter))}</div>`);

            const sections = []
                .concat(chosen.length ? [`<div style="margin-bottom:10px;">${chosen.join('')}</div>`] : [])
                .concat(runLines.length ? [`<div style="margin-bottom:10px;">${runLines.join('')}</div>`] : [])
                .concat(selectionLines.length ? [`<div style="margin-bottom:10px;">${selectionLines.join('')}</div>`] : [])
                .concat(refreshLines.length ? [`<div>${refreshLines.join('')}</div>`] : []);

            body.innerHTML = sections.length ? sections.join('') : '<div class="muted">No run metadata available.</div>';
            card.style.display = '';
        }

        async function loadJobPicker() {
            const picker = document.getElementById('job-picker');
            if (!picker) return;

            // Default option (no job_id => latest)
            picker.innerHTML = `<option value="">Latest</option>`;

            try {
                const resp = await fetch('/api/job-history');
                const data = await resp.json();
                const history = (data && data.success && Array.isArray(data.history)) ? data.history : [];

                // Only show completed jobs first (others can appear but won't have stable results).
                const completed = history.filter(j => j && typeof j === 'object' && j.status === 'completed');
                completed.forEach((j) => {
                    const id = j.job_id;
                    if (!id) return;
                    const started = fmtIso(j.started_at);
                    const typ = j.job_type || 'job';
                    const sel = (j.group_names || '').toString();
                    const label = `${started} ‚Äî ${typ}${sel ? ` ‚Äî ${sel}` : ''}`.trim();
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = label;
                    picker.appendChild(opt);
                });
            } catch {
                // ignore picker load failures; page still works
            }

            // Select current job.
            picker.value = jobId || '';
            picker.addEventListener('change', (e) => {
                const v = e.target && e.target.value ? String(e.target.value) : '';
                window.location.href = v ? `/results?job_id=${encodeURIComponent(v)}` : '/results';
            });
        }

        setExportLink();
        loadJobPicker();

        function renderRefreshBreakdown(summary) {
            const card = document.getElementById('refresh-breakdown-card');
            const tbody = document.getElementById('refresh-change-tbody');
            if (!card || !tbody) return;

            const previous = Array.isArray(summary?.previous_streams) ? summary.previous_streams : [];
            const finalStreams = Array.isArray(summary?.final_streams)
                ? summary.final_streams
                : (Array.isArray(summary?.streams) ? summary.streams : []);

            const finalIds = new Set(finalStreams.map((s) => String(s?.id ?? s?.stream_id ?? '')));
            const previousIds = new Set(previous.map((s) => String(s?.id ?? s?.stream_id ?? '')));

            const rows = [];

            finalStreams.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                const status = previousIds.has(id) ? 'Kept' : 'Added';
                rows.push({ ...s, status });
            });

            previous.forEach((s) => {
                const id = String(s?.id ?? s?.stream_id ?? '');
                if (!finalIds.has(id)) {
                    rows.push({ ...s, status: 'Removed' });
                }
            });

            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="7" class="muted">No stream details available for this refresh.</td></tr>';
                card.style.display = '';
                return;
            }

            tbody.innerHTML = rows.map((row) => {
                const name = row?.name || row?.stream_name || `Stream ${row?.id ?? ''}`;
                const pid = row?.provider_id ?? row?.providerid ?? row?.provider;
                const providerCell = providerLabelHtml(pid ?? row?.provider_name) || escapeHtml(row?.provider_name || '');
                const serviceName = row?.service_name ? escapeHtml(String(row.service_name)) : '';
                const serviceProvider = row?.service_provider ? escapeHtml(String(row.service_provider)) : '';
                const resolution = escapeHtml(row?.resolution || '‚Äî');
                const bitrate = fmtBitrate(row?.bitrate_kbps);
                const statusClass = row.status === 'Removed' ? 'badge removed' : (row.status === 'Added' ? 'badge added' : 'badge unchanged');
                return `
                    <tr>
                        <td><span class="${statusClass}">${escapeHtml(row.status || '')}</span></td>
                        <td>${escapeHtml(String(name))}</td>
                        <td>${providerCell}</td>
                        <td>${serviceName}</td>
                        <td>${serviceProvider}</td>
                        <td>${resolution}</td>
                        <td>${bitrate}</td>
                    </tr>
                `;
            }).join('');

            card.style.display = '';
        }

        function renderOrderingTables(ordering) {
            const card = document.getElementById('ordering-visibility-card');
            if (!card) return;
            const finalBody = document.getElementById('final-order-tbody');
            const excludedBody = document.getElementById('excluded-stream-tbody');
            if (!finalBody || !excludedBody) return;

            const finalOrders = Array.isArray(ordering?.final_orders) ? ordering.final_orders : [];
            const excluded = Array.isArray(ordering?.excluded_streams) ? ordering.excluded_streams : [];

            if (!finalOrders.length && !excluded.length) {
                card.style.display = 'none';
                return;
            }

            const sortedFinal = [...finalOrders].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const orderA = Number(a?.order ?? 0);
                const orderB = Number(b?.order ?? 0);
                return orderA - orderB;
            });

            finalBody.innerHTML = sortedFinal.map((row) => {
                try {
                    const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                    const validation = row?.validation_result ? escapeHtml(String(row.validation_result)) : '‚Äî';
                    return `
                        <tr>
                            <td>${channelLabelFrom(row)}</td>
                            <td class="mono">${escapeHtml(row?.order ?? '')}</td>
                            <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                            <td>${providerCell}</td>
                            <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                            <td>${escapeHtml(row?.video_codec || '‚Äî')}</td>
                            <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                            <td>${validation}</td>
                        </tr>
                    `;
                } catch (err) {
                    console.warn('Failed to render final order row:', err, row);
                    return `
                        <tr>
                            <td colspan="8" class="muted">Unable to render a final-order row for this stream.</td>
                        </tr>
                    `;
                }
            }).join('');

            const sortedExcluded = [...excluded].sort((a, b) => {
                const chanA = `${a?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${b?.channel_number ?? ''}`.padStart(6, '0');
                if (chanA !== chanB) return chanA.localeCompare(chanB);
                const nameA = (a?.stream_name || '').toString().toLowerCase();
                const nameB = (b?.stream_name || '').toString().toLowerCase();
                return nameA.localeCompare(nameB);
            });

            excludedBody.innerHTML = sortedExcluded.map((row) => {
                try {
                    const providerCell = providerLabelHtml(row?.provider_id) || escapeHtml(row?.provider_name || '');
                    const serviceName = row?.service_name ? escapeHtml(String(row.service_name)) : '';
                    const serviceProvider = row?.service_provider ? escapeHtml(String(row.service_provider)) : '';
                    return `
                        <tr>
                            <td>${channelLabelFrom(row)}</td>
                            <td>${escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`)}</td>
                            <td>${providerCell}</td>
                            <td>${serviceName}</td>
                            <td>${serviceProvider}</td>
                            <td>${escapeHtml(row?.resolution || '‚Äî')}</td>
                            <td>${fmtBitrate(row?.bitrate_kbps)}</td>
                            <td>${escapeHtml(row?.reason || '‚Äî')}</td>
                        </tr>
                    `;
                } catch (err) {
                    console.warn('Failed to render excluded row:', err, row);
                    return `
                        <tr>
                            <td colspan="8" class="muted">Unable to render an excluded stream row.</td>
                        </tr>
                    `;
                }
            }).join('');

            if (!excluded.length) {
                excludedBody.innerHTML = '<tr><td colspan="8" class="muted">No streams were excluded.</td></tr>';
            }

            card.style.display = '';
        }

        function parseResolutionValue(resolution) {
            if (!resolution) return null;
            const text = String(resolution).toLowerCase();
            if (text.includes('x')) {
                const parts = text.split('x');
                if (parts.length >= 2) {
                    const height = Number(parts[1].replace(/[^\d]/g, ''));
                    if (!Number.isNaN(height) && height > 0) return height;
                }
            }
            const match = text.match(/(\d{3,4})p/);
            if (match) {
                const val = Number(match[1]);
                return Number.isNaN(val) ? null : val;
            }
            const digits = text.match(/(\d{3,4})/);
            if (digits) {
                const val = Number(digits[1]);
                return Number.isNaN(val) ? null : val;
            }
            return null;
        }

        function isValidationOk(result) {
            if (!result) return true;
            const val = String(result).toLowerCase();
            return ['ok', 'pass', 'passed', 'success'].includes(val);
        }

        function formatScore(score) {
            if (score === null || score === undefined || score === 'N/A') return '‚Äî';
            const num = Number(score);
            if (Number.isNaN(num)) return escapeHtml(String(score));
            return num.toFixed(1);
        }

        function humanizeValidationDetail(detail) {
            if (!detail) return '';
            const text = String(detail);
            const lower = text.toLowerCase();
            const exactMap = {
                err_timeout_excess: 'validation timeout during probing',
                err_timeout: 'validation timeout',
                err_probe_timeout: 'validation timeout during probing',
                err_probe_fail: 'validation probe failure',
                stream_unreachable: 'stream unreachable during validation',
                err_unreachable: 'stream unreachable during validation',
                err_http_status: 'unexpected HTTP response during validation',
                err_invalid_response: 'invalid response during validation',
                invalid_response: 'invalid response during validation'
            };
            if (Object.prototype.hasOwnProperty.call(exactMap, lower)) {
                return exactMap[lower];
            }
            let cleaned = text;
            Object.entries(exactMap).forEach(([key, value]) => {
                const re = new RegExp(key, 'ig');
                cleaned = cleaned.replace(re, value);
            });
            cleaned = cleaned.replace(/_/g, ' ').replace(/\berr\b/gi, 'error');
            return cleaned;
        }

        function formatValidationSummary(result, reason) {
            if (!result) return '';
            if (isValidationOk(result)) return 'successful validation checks';
            const detail = humanizeValidationDetail(reason || result);
            return detail ? `validation issue (${detail})` : 'validation issue';
        }

        function collectFactors(row, topRow) {
            const factors = new Set();
            const detail = {};
            const validation = row?.validation_result;
            if (validation && !isValidationOk(validation)) {
                factors.add('validation');
                detail.validation = formatValidationSummary(validation, row?.validation_reason);
            }

            const topResolution = parseResolutionValue(topRow?.resolution);
            const rowResolution = parseResolutionValue(row?.resolution);
            if (topResolution && rowResolution && rowResolution < topResolution) {
                factors.add('resolution');
                detail.resolution = `${rowResolution}p vs ${topResolution}p`;
            }

            const topBitrate = Number(topRow?.bitrate_kbps);
            const rowBitrate = Number(row?.bitrate_kbps);
            if (!Number.isNaN(topBitrate) && !Number.isNaN(rowBitrate) && topBitrate > 0) {
                if (rowBitrate < topBitrate * 0.9) {
                    factors.add('bitrate');
                    detail.bitrate = `${Math.round(rowBitrate)} vs ${Math.round(topBitrate)} kbps`;
                }
            }

            const topScore = Number(topRow?.final_score);
            const rowScore = Number(row?.final_score);
            if (!Number.isNaN(topScore) && !Number.isNaN(rowScore) && rowScore < topScore) {
                const diff = topScore - rowScore;
                if (diff >= 0.1) {
                    factors.add('score');
                    detail.score = `${diff.toFixed(1)} points behind`;
                }
            }

            return { factors, detail };
        }

        function formatFactorsList(factors) {
            const phrases = {
                validation: 'validation stability',
                resolution: 'resolution consistency',
                bitrate: 'effective bitrate',
                score: 'overall quality score'
            };
            return Array.from(factors)
                .map((f) => phrases[f])
                .filter(Boolean);
        }

        function renderOrderingExplanation(ordering) {
            const card = document.getElementById('ordering-explanation-card');
            if (!card) return;

            const finalOrders = Array.isArray(ordering?.final_orders) ? ordering.final_orders : [];
            if (!finalOrders.length) {
                card.innerHTML = `
                    <h2>Why streams were ordered this way</h2>
                    <div class="muted small">No ordering explanation available for this run.</div>
                `;
                return;
            }

            const channelMap = new Map();
            finalOrders.forEach((row) => {
                const label = channelLabelFrom(row);
                if (!channelMap.has(label)) {
                    channelMap.set(label, []);
                }
                channelMap.get(label).push(row);
            });

            const sortedChannels = Array.from(channelMap.entries()).sort((a, b) => {
                const aRow = a[1][0] || {};
                const bRow = b[1][0] || {};
                const chanA = `${aRow?.channel_number ?? ''}`.padStart(6, '0');
                const chanB = `${bRow?.channel_number ?? ''}`.padStart(6, '0');
                return chanA.localeCompare(chanB);
            });

            const blocks = sortedChannels.map(([label, rows]) => {
                try {
                    const ordered = [...rows].sort((a, b) => Number(a?.order ?? 0) - Number(b?.order ?? 0));
                    const top = ordered[0];
                    if (!top) return '';

                    const topName = escapeHtml(top?.stream_name || `Stream ${top?.stream_id ?? ''}`);
                    const slot1Reason = typeof top?.slot1_reason === 'string' ? top.slot1_reason : '';
                    const topReasons = [];
                    if (!slot1Reason) {
                        if (top?.resolution) topReasons.push(`stable ${escapeHtml(String(top.resolution))} resolution`);
                        const validationSummary = formatValidationSummary(top?.validation_result, top?.validation_reason);
                        if (validationSummary) topReasons.push(escapeHtml(validationSummary));
                        if (top?.bitrate_kbps) topReasons.push(`strong bitrate (${fmtBitrate(top.bitrate_kbps)})`);
                        if (top?.final_score !== null && top?.final_score !== undefined) {
                            topReasons.push(`highest overall quality score (${formatScore(top.final_score)})`);
                        }
                    }
                    const topReasonText = slot1Reason
                        ? escapeHtml(slot1Reason)
                        : topReasons.length
                            ? topReasons.join(', ')
                            : 'the strongest overall performance across the checks';

                    const topLine = `Chosen as the top stream: <strong>${topName}</strong> because it delivered ${topReasonText}.`;

                    const nonTop = ordered.slice(1);
                    const factorSet = new Set();
                    const validationHighlights = [];

                    nonTop.forEach((row) => {
                        const { factors, detail } = collectFactors(row, top);
                        factors.forEach((f) => factorSet.add(f));
                        if (detail.validation && validationHighlights.length < 2) {
                            validationHighlights.push({
                                name: escapeHtml(row?.stream_name || `Stream ${row?.stream_id ?? ''}`),
                                note: escapeHtml(detail.validation)
                            });
                        }
                    });

                    const factorsForSummary = new Set(factorSet);
                    if (validationHighlights.length) factorsForSummary.delete('validation');

                    const factorList = formatFactorsList(factorsForSummary);
                    const lowSummary = factorList.length
                        ? `Other available streams ranked lower mainly due to ${escapeHtml(factorList.join(', '))}.`
                        : 'Other available streams ranked lower on overall performance.';

                    const bulletLines = validationHighlights.map((item) => (
                        `<li>${item.name} showed ${item.note}.</li>`
                    ));

                    return `
                        <div class="explanation-block">
                            <h3>${label}</h3>
                            <p>${topLine}</p>
                            <p class="muted small">${lowSummary}</p>
                            ${bulletLines.length ? `<p class="muted small">Notable differences:</p><ul>${bulletLines.join('')}</ul>` : ''}
                        </div>
                    `;
                } catch (err) {
                    console.warn('Failed to render ordering explanation block:', err, rows);
                    return `
                        <div class="explanation-block">
                            <h3>${label}</h3>
                            <p class="muted small">Unable to render narrative details for this channel.</p>
                        </div>
                    `;
                }
            }).filter(Boolean);

            card.innerHTML = `
                <h2>Why streams were ordered this way</h2>
                ${blocks.join('')}
            `;
        }

        fetch(resultsUrl)
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.body.innerHTML = '<div style="text-align:center;padding:40px;color:white;"><h2>No results available</h2><p>Run an analysis first.</p><a href="/" style="color:white;">Go Back</a></div>';
                    return;
                }
                
                const r = data.results;
                providerNames = data.provider_names || {};
                renderJobMeta(data.job_meta || null);
                const jobType = r.job_type || data.job_type;
                const analyzedStreams = typeof data.analyzed_streams === 'number'
                    ? data.analyzed_streams
                    : (typeof r.total === 'number' ? r.total : 0);
                
                // Check if this is a refresh job
                if (jobType === 'refresh') {
                    // Show refresh-specific results
                    document.querySelector('.header h1').textContent = 'üîÑ Channel Refresh Results';
                    document.querySelector('.header p').textContent = 'Stream Replacement Summary';
                    
                    document.getElementById('stat-total').textContent = r.total_matching.toLocaleString();
                    document.querySelector('#stat-total').previousElementSibling.textContent = 'Total Matching Streams Found';
                    
                    document.getElementById('stat-success').textContent = r.new_count.toLocaleString();
                    document.querySelector('#stat-success').previousElementSibling.textContent = 'Streams Added';
                    
                    document.getElementById('stat-failed').textContent = r.previous_count.toLocaleString();
                    document.querySelector('#stat-failed').previousElementSibling.textContent = 'Streams Removed';
                    document.querySelector('#stat-failed').classList.remove('failed');
                    document.querySelector('#stat-failed').style.color = '#718096';
                    
                    document.getElementById('stat-rate').textContent = 'Refresh Complete';
                    document.querySelector('#stat-rate').previousElementSibling.textContent = 'Status';
                    
                    // Add filter info if present
                    if (r.include_filter || r.exclude_filter) {
                        const filterCard = document.createElement('div');
                        filterCard.className = 'card';
                        filterCard.innerHTML = `
                            <h2>üîç Filters Applied</h2>
                            ${r.include_filter ? `<p><strong>Include:</strong> ${r.include_filter}</p>` : ''}
                            ${r.exclude_filter ? `<p><strong>Exclude:</strong> ${r.exclude_filter}</p>` : ''}
                        `;
                        document.querySelectorAll('.card')[0].after(filterCard);
                    }

                    renderRefreshBreakdown(r);

                    return;
                }

                if (data.analysis_ran === false) {
                    showWarning('No analysis ran for this job', 'This job did not execute stream analysis.');
                    return;
                }

                if (analyzedStreams === 0) {
                    showWarning('No analysis results', 'Stream analysis ran but produced zero analyzed streams.');
                    return;
                }
                
                // Otherwise, show analysis results
                document.getElementById('stat-total').textContent = r.total.toLocaleString();
                document.getElementById('stat-success').textContent = r.successful.toLocaleString();
                document.getElementById('stat-failed').textContent = r.failed.toLocaleString();
                document.getElementById('stat-rate').textContent = r.success_rate + '%';
                const capacitySummary = r.capacity_summary || data.capacity_summary;
                if (capacitySummary && capacitySummary.warning) {
                    const capacityEl = document.getElementById('capacity-warning');
                    capacityEl.textContent = capacitySummary.warning;
                    capacityEl.style.display = 'block';
                }

                const orderingVisibility = data.ordering_visibility || r.ordering_visibility;
                renderOrderingTables(orderingVisibility);
                renderOrderingExplanation(orderingVisibility);

            })
            .catch(err => {
                console.error('Failed to load results:', err);
                showWarning('Failed to load results', 'An error occurred while loading the analysis results.');
            });
    </script>
</body>
</html>
