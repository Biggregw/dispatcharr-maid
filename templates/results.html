<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Results - Dispatcharr Maid</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .nav-buttons { text-align: center; margin-bottom: 20px; }
        .btn { padding: 12px 30px; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; background: white; color: #667eea; margin: 0 10px; transition: all 0.3s; text-decoration: none; display: inline-block; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .card { background: white; border-radius: 15px; padding: 25px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; border-bottom: 2px solid #667eea; padding-bottom: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-box { background: #f7fafc; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; }
        .stat-label { color: #718096; font-size: 0.9em; margin-bottom: 5px; }
        .stat-value { font-size: 2em; font-weight: bold; color: #2d3748; }
        .stat-value.success { color: #38a169; }
        .stat-value.failed { color: #e53e3e; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #eef2ff; color: #667eea; font-weight: 600; }
        tr:hover { background: #f7fafc; }
        .success-badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.9em; font-weight: 600; }
        .success-badge.excellent { background: #c6f6d5; color: #22543d; }
        .success-badge.good { background: #bee3f8; color: #2c5282; }
        .success-badge.fair { background: #feebc8; color: #7c2d12; }
        .success-badge.poor { background: #fed7d7; color: #742a2a; }
        .capacity-warning { margin-top: 12px; color: #97266d; font-weight: 600; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e2e8f0; }
        .tab { padding: 12px 24px; cursor: pointer; border: none; background: none; font-size: 1em; font-weight: 600; color: #718096; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .muted { color: #718096; }
        .small { font-size: 0.9em; }
        .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background: #edf2f7; color:#2d3748; font-weight: 600; font-size: 0.85em; }
        .btn-sm { padding: 10px 14px; border-radius: 8px; font-size: 0.95em; }
        .input { width: 100%; padding: 10px 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 1em; }
        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
        .stream-tools { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
        .codebox { margin-top: 10px; padding: 12px; background: #f7fafc; border-radius: 10px; border: 1px solid #e2e8f0; }
        code { word-break: break-word; }
        .stream-table-wrap { overflow-x: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Analysis Results</h1>
            <p>Detailed Stream Quality Report</p>
        </div>
        
        <div class="nav-buttons">
            <a href="/" class="btn">‚Üê Back to Control Panel</a>
            <a href="/api/results/csv" class="btn" id="export-csv-link">üì• Export CSV</a>
            <span style="display:inline-block;color:white;font-weight:600;margin-left:10px;">Run:</span>
            <select id="job-picker" class="input" style="display:inline-block; width:auto; min-width: 320px; max-width: 520px; margin-left:8px;"></select>
        </div>
        
        <div class="card">
            <h2>üìà Overall Summary</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">Total Streams Analyzed</div>
                    <div class="stat-value" id="stat-total">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Successful</div>
                    <div class="stat-value success" id="stat-success">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value failed" id="stat-failed">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="stat-rate">0%</div>
                </div>
            </div>
            <div id="capacity-warning" class="capacity-warning" style="display:none;"></div>
        </div>

        <div class="card" id="run-meta-card" style="display:none;">
            <h2>üßæ Run Details</h2>
            <div id="run-meta-body" class="muted small"></div>
        </div>
        
        <div class="card" id="detailed-breakdown-card">
            <h2>üîç Detailed Breakdown</h2>
            <div class="tabs">
                <button class="tab active" onclick="showTab('streams')">Streams</button>
                <button class="tab" onclick="showTab('providers')">Providers</button>
                <button class="tab" onclick="showTab('channels')">Channels</button>
                <button class="tab" onclick="showTab('errors')">Errors</button>
                <button class="tab" onclick="showTab('plan')">Planned Changes</button>
            </div>
            
            <div id="providers-tab" class="tab-content">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin: 10px 0 0 0;">
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        <input type="checkbox" id="show-all-providers" />
                        Show all providers (including 0 streams)
                    </label>
                    <div id="provider-count-note" style="color:#718096;font-size:0.95em;"></div>
                </div>
                <table id="provider-table">
                    <thead>
                        <tr>
                            <th>Provider</th>
                            <th>Total Streams</th>
                            <th>Successful</th>
                            <th>Failed</th>
                            <th>Success Rate</th>
                            <th>Avg Quality</th>
                            <th>Max Streams</th>
                        </tr>
                    </thead>
                    <tbody id="provider-tbody"></tbody>
                </table>
            </div>
            
            <div id="channels-tab" class="tab-content">
                <table id="channel-table">
                    <thead>
                        <tr>
                            <th>Channel</th>
                            <th>Total Streams</th>
                            <th>Successful</th>
                            <th>Failed</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody id="channel-tbody"></tbody>
                </table>
            </div>
            
            <div id="errors-tab" class="tab-content">
                <div id="error-list"></div>
            </div>

            <div id="plan-tab" class="tab-content">
                <div class="row" style="justify-content: space-between; margin-top: 6px;">
                    <div class="muted small">
                        Plan-only runs generate an exact <strong>before vs after</strong> stream list per channel, but do <strong>not</strong> update Dispatcharr.
                    </div>
                    <div class="pill" id="plan-count-pill">0 channels</div>
                </div>

                <div class="stream-tools">
                    <label style="display:flex;align-items:center;gap:8px;color:#4a5568;font-weight:600;">
                        <input type="checkbox" id="plan-changed-only" checked />
                        Show changed only
                    </label>
                    <span id="plan-status" class="muted small"></span>
                </div>

                <div class="stream-table-wrap">
                    <table id="plan-table">
                        <thead>
                            <tr>
                                <th>Channel</th>
                                <th>Before</th>
                                <th>After</th>
                                <th>Removed</th>
                                <th>Added</th>
                                <th>Preview (first 30)</th>
                            </tr>
                        </thead>
                        <tbody id="plan-tbody"></tbody>
                    </table>
                </div>
            </div>

            <div id="streams-tab" class="tab-content active">
                <div class="row" style="justify-content: space-between; margin-top: 6px;">
                    <div class="muted small">
                        Tick streams you want the regex to <strong>match</strong>. Untick streams you want it to <strong>exclude</strong> (e.g. untick any ‚Äúdolby‚Äù variants).
                    </div>
                    <div class="pill" id="streams-count-pill">0 streams</div>
                </div>

                <div class="stream-tools">
                    <input id="stream-search" class="input" style="max-width: 520px;" type="text" placeholder="üîç Filter streams by name (client-side)" oninput="filterStreamRows()" />
                    <button class="btn btn-sm" type="button" onclick="selectAllStreams()">Select all</button>
                    <button class="btn btn-sm" type="button" onclick="clearAllStreams()">Clear all</button>
                    <button class="btn btn-sm" type="button" style="background:#667eea;color:white;" onclick="generateStreamRegex()">Generate minimal regex</button>
                    <button class="btn btn-sm" type="button" onclick="copyStreamRegex()" id="copy-stream-regex-btn" disabled>Copy regex</button>
                    <span id="stream-regex-status" class="muted small"></span>
                </div>

                <div id="stream-regex-output" class="codebox" style="display:none;">
                    <div style="font-weight:700; color:#2d3748; margin-bottom:6px;">Suggested regex</div>
                    <code id="stream-regex-code"></code>
                </div>

                <div class="stream-table-wrap">
                    <table id="stream-table">
                        <thead>
                            <tr>
                                <th style="width: 70px;">Use</th>
                                <th>Stream</th>
                                <th>Status</th>
                                <th>Quality</th>
                                <th>Resolution</th>
                                <th>Provider</th>
                            </tr>
                        </thead>
                        <tbody id="stream-tbody"></tbody>
                    </table>
                </div>
                <div id="streams-loading" class="muted small" style="margin-top:10px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        const params = new URLSearchParams(window.location.search);
        const jobId = params.get('job_id');
        const resultsUrl = jobId ? `/api/results/job/${encodeURIComponent(jobId)}` : '/api/results/detailed';
        let streamsLoaded = false;
        let planLoaded = false;
        // Populated from the detailed results payload; reused by the Streams tab.
        let providerNames = {};
        let providerMetadata = {};

        function escapeHtml(str) {
            const s = String(str ?? '');
            return s.replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[c]));
        }

        function showWarning(title, message) {
            document.body.innerHTML = `
                <div style="text-align:center;padding:40px;color:white;">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <a href="/" style="color:white;">Go Back</a>
                </div>
            `;
        }

        function providerLabelHtml(providerId) {
            if ((providerId ?? '') === '') return '';
            const pid = String(providerId);
            const label = Object.prototype.hasOwnProperty.call(providerNames, pid)
                ? providerNames[pid]
                : `Provider ${pid}`;
            return `<span title="Provider ${escapeHtml(pid)}">${escapeHtml(String(label))}</span>`;
        }

        function setExportLink() {
            const link = document.getElementById('export-csv-link');
            if (!link) return;
            link.href = jobId ? `/api/results/csv?job_id=${encodeURIComponent(jobId)}` : '/api/results/csv';
        }

        function fmtIso(iso) {
            if (!iso) return '';
            try {
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return String(iso);
                return d.toLocaleString();
            } catch {
                return String(iso);
            }
        }

        function renderJobMeta(meta) {
            const card = document.getElementById('run-meta-card');
            const body = document.getElementById('run-meta-body');
            if (!card || !body) return;
            if (!meta || typeof meta !== 'object') {
                card.style.display = 'none';
                body.innerHTML = '';
                return;
            }

            const selection = meta.selection || {};
            const groupIds = Array.isArray(selection.channel_group_ids) ? selection.channel_group_ids : [];
            const channelIds = Array.isArray(selection.specific_channel_ids) ? selection.specific_channel_ids : [];
            const nameRegex = selection.channel_name_regex || '';
            const numRegex = selection.channel_number_regex || '';
            const refreshRegex = selection.refresh_stream_name_regex || '';

            const selectionLines = [];
            if (groupIds.length) selectionLines.push(`<div><strong>Groups (config)</strong>: ${escapeHtml(groupIds.join(', '))}</div>`);
            if (channelIds.length) selectionLines.push(`<div><strong>Specific channels (config)</strong>: ${escapeHtml(channelIds.slice(0, 50).join(', '))}${channelIds.length > 50 ? '‚Ä¶' : ''}</div>`);
            if (nameRegex) selectionLines.push(`<div><strong>Channel name regex</strong>: <code>${escapeHtml(nameRegex)}</code></div>`);
            if (numRegex) selectionLines.push(`<div><strong>Channel number regex</strong>: <code>${escapeHtml(numRegex)}</code></div>`);
            if (refreshRegex) selectionLines.push(`<div><strong>Refresh stream regex</strong>: <code>${escapeHtml(refreshRegex)}</code></div>`);

            const chosen = [];
            if (meta.group_names) chosen.push(`<div><strong>Selected</strong>: ${escapeHtml(String(meta.group_names))}${meta.channel_names ? ` ‚Äî ${escapeHtml(String(meta.channel_names))}` : ''}</div>`);
            if (meta.regex_preset_name) chosen.push(`<div><strong>Preset</strong>: ${escapeHtml(String(meta.regex_preset_name))}</div>`);
            if (meta.selection_pattern_name) chosen.push(`<div><strong>Pattern</strong>: ${escapeHtml(String(meta.selection_pattern_name))}</div>`);

            const runLines = [
                `<div><strong>Job</strong>: ${escapeHtml(String(meta.job_id || 'latest'))}</div>`,
                meta.job_type ? `<div><strong>Type</strong>: ${escapeHtml(String(meta.job_type))}</div>` : '',
                meta.status ? `<div><strong>Status</strong>: ${escapeHtml(String(meta.status))}</div>` : '',
                meta.started_at ? `<div><strong>Started</strong>: ${escapeHtml(fmtIso(meta.started_at))}</div>` : '',
                meta.completed_at ? `<div><strong>Completed</strong>: ${escapeHtml(fmtIso(meta.completed_at))}</div>` : '',
                meta.config_hash ? `<div><strong>Config hash</strong>: <code>${escapeHtml(String(meta.config_hash))}</code></div>` : '',
            ].filter(Boolean);

            const refreshLines = [];
            if (meta.base_search_text) refreshLines.push(`<div><strong>Base search</strong>: ${escapeHtml(String(meta.base_search_text))}</div>`);
            if (meta.include_filter) refreshLines.push(`<div><strong>Include filter</strong>: ${escapeHtml(String(meta.include_filter))}</div>`);
            if (meta.exclude_filter) refreshLines.push(`<div><strong>Exclude filter</strong>: ${escapeHtml(String(meta.exclude_filter))}</div>`);
            if (meta.exclude_plus_one === true) refreshLines.push(`<div><strong>Exclude +1</strong>: true</div>`);
            if (meta.exclude_4k === true) refreshLines.push(`<div><strong>Exclude 4K</strong>: true</div>`);
            if (typeof meta.streams_per_provider === 'number') refreshLines.push(`<div><strong>Streams per provider</strong>: ${escapeHtml(String(meta.streams_per_provider))}</div>`);
            if (meta.stream_name_regex) refreshLines.push(`<div><strong>Stream regex (filter)</strong>: <code>${escapeHtml(String(meta.stream_name_regex))}</code></div>`);
            if (meta.stream_name_regex_override) refreshLines.push(`<div><strong>Stream regex (override)</strong>: <code>${escapeHtml(String(meta.stream_name_regex_override))}</code></div>`);

            const sections = []
                .concat(chosen.length ? [`<div style="margin-bottom:10px;">${chosen.join('')}</div>`] : [])
                .concat(runLines.length ? [`<div style="margin-bottom:10px;">${runLines.join('')}</div>`] : [])
                .concat(selectionLines.length ? [`<div style="margin-bottom:10px;">${selectionLines.join('')}</div>`] : [])
                .concat(refreshLines.length ? [`<div>${refreshLines.join('')}</div>`] : []);

            body.innerHTML = sections.length ? sections.join('') : '<div class="muted">No run metadata available.</div>';
            card.style.display = '';
        }

        async function loadJobPicker() {
            const picker = document.getElementById('job-picker');
            if (!picker) return;

            // Default option (no job_id => latest)
            picker.innerHTML = `<option value="">Latest</option>`;

            try {
                const resp = await fetch('/api/job-history');
                const data = await resp.json();
                const history = (data && data.success && Array.isArray(data.history)) ? data.history : [];

                // Only show completed jobs first (others can appear but won't have stable results).
                const completed = history.filter(j => j && typeof j === 'object' && j.status === 'completed');
                completed.forEach((j) => {
                    const id = j.job_id;
                    if (!id) return;
                    const started = fmtIso(j.started_at);
                    const typ = j.job_type || 'job';
                    const sel = (j.group_names || '').toString();
                    const label = `${started} ‚Äî ${typ}${sel ? ` ‚Äî ${sel}` : ''}`.trim();
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = label;
                    picker.appendChild(opt);
                });
            } catch {
                // ignore picker load failures; page still works
            }

            // Select current job.
            picker.value = jobId || '';
            picker.addEventListener('change', (e) => {
                const v = e.target && e.target.value ? String(e.target.value) : '';
                window.location.href = v ? `/results?job_id=${encodeURIComponent(v)}` : '/results';
            });
        }

        setExportLink();
        loadJobPicker();

        function refreshStreamProviderLabels() {
            document.querySelectorAll('#stream-tbody .stream-row').forEach((row) => {
                const pid = row.getAttribute('data-provider-id') || '';
                const cell = row.querySelector('td:nth-child(6)');
                if (cell) cell.innerHTML = providerLabelHtml(pid);
            });
        }

        fetch(resultsUrl)
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.body.innerHTML = '<div style="text-align:center;padding:40px;color:white;"><h2>No results available</h2><p>Run an analysis first.</p><a href="/" style="color:white;">Go Back</a></div>';
                    return;
                }
                
                const r = data.results;
                providerNames = data.provider_names || {};
                providerMetadata = data.provider_metadata || {};
                renderJobMeta(data.job_meta || null);
                if (streamsLoaded) refreshStreamProviderLabels();
                const jobType = r.job_type || data.job_type;
                const analyzedStreams = typeof data.analyzed_streams === 'number'
                    ? data.analyzed_streams
                    : (typeof r.total === 'number' ? r.total : 0);
                
                // Check if this is a refresh job
                if (jobType === 'refresh') {
                    // Show refresh-specific results
                    document.querySelector('.header h1').textContent = 'üîÑ Channel Refresh Results';
                    document.querySelector('.header p').textContent = 'Stream Replacement Summary';
                    
                    document.getElementById('stat-total').textContent = r.total_matching.toLocaleString();
                    document.querySelector('#stat-total').previousElementSibling.textContent = 'Total Matching Streams Found';
                    
                    document.getElementById('stat-success').textContent = r.new_count.toLocaleString();
                    document.querySelector('#stat-success').previousElementSibling.textContent = 'Streams Added';
                    
                    document.getElementById('stat-failed').textContent = r.previous_count.toLocaleString();
                    document.querySelector('#stat-failed').previousElementSibling.textContent = 'Streams Removed';
                    document.querySelector('#stat-failed').classList.remove('failed');
                    document.querySelector('#stat-failed').style.color = '#718096';
                    
                    document.getElementById('stat-rate').textContent = 'Refresh Complete';
                    document.querySelector('#stat-rate').previousElementSibling.textContent = 'Status';
                    
                    // Hide the detailed breakdown section
                    const breakdownCard = document.getElementById('detailed-breakdown-card');
                    if (breakdownCard) {
                        breakdownCard.style.display = 'none';
                    }
                    
                    // Add filter info if present
                    if (r.include_filter || r.exclude_filter) {
                        const filterCard = document.createElement('div');
                        filterCard.className = 'card';
                        filterCard.innerHTML = `
                            <h2>üîç Filters Applied</h2>
                            ${r.include_filter ? `<p><strong>Include:</strong> ${r.include_filter}</p>` : ''}
                            ${r.exclude_filter ? `<p><strong>Exclude:</strong> ${r.exclude_filter}</p>` : ''}
                        `;
                        document.querySelectorAll('.card')[0].after(filterCard);
                    }
                    
                    return;
                }

                if (data.analysis_ran === false) {
                    showWarning('No analysis ran for this job', 'This job did not execute stream analysis.');
                    return;
                }

                if (analyzedStreams === 0) {
                    showWarning('No analysis results', 'Stream analysis ran but produced zero analyzed streams.');
                    return;
                }
                
                // Otherwise, show analysis results
                document.getElementById('stat-total').textContent = r.total.toLocaleString();
                document.getElementById('stat-success').textContent = r.successful.toLocaleString();
                document.getElementById('stat-failed').textContent = r.failed.toLocaleString();
                document.getElementById('stat-rate').textContent = r.success_rate + '%';
                const capacitySummary = r.capacity_summary || data.capacity_summary;
                if (capacitySummary && capacitySummary.warning) {
                    const capacityEl = document.getElementById('capacity-warning');
                    capacityEl.textContent = capacitySummary.warning;
                    capacityEl.style.display = 'block';
                }
                
                // Providers
                const tbody = document.getElementById('provider-tbody');
                const providerCountNote = document.getElementById('provider-count-note');
                const showAllProvidersEl = document.getElementById('show-all-providers');

                function renderProviders(showAll) {
                    const providerStats = r.provider_stats || {};
                    const providerStatsEntries = Object.entries(providerStats);
                    const configuredProviderIds = Object.keys(providerNames || {});

                    // If we don't have a configured provider list, fall back to what the run produced.
                    const providerIds = (showAll && configuredProviderIds.length > 0)
                        ? configuredProviderIds
                        : providerStatsEntries.map(([id]) => id);

                    const rows = providerIds.map((id) => {
                        const stats = Object.prototype.hasOwnProperty.call(providerStats, id)
                            ? providerStats[id]
                            : { total: 0, successful: 0, failed: 0, success_rate: 0, avg_quality: '‚Äî' };
                        return [id, stats];
                    });

                    // Sort: providers with data first, then by success rate (ascending like before), then by name.
                    rows.sort((a, b) => {
                        const aHasData = (a[1]?.total || 0) > 0;
                        const bHasData = (b[1]?.total || 0) > 0;
                        if (aHasData !== bHasData) return aHasData ? -1 : 1;
                        const aRate = typeof a[1]?.success_rate === 'number' ? a[1].success_rate : 0;
                        const bRate = typeof b[1]?.success_rate === 'number' ? b[1].success_rate : 0;
                        if (aRate !== bRate) return aRate - bRate;
                        const aName = Object.prototype.hasOwnProperty.call(providerNames, a[0]) ? providerNames[a[0]] : `${a[0]}`;
                        const bName = Object.prototype.hasOwnProperty.call(providerNames, b[0]) ? providerNames[b[0]] : `${b[0]}`;
                        return aName.localeCompare(bName);
                    });

                    providerCountNote.textContent = `Showing ${providerStatsEntries.length} provider${providerStatsEntries.length === 1 ? '' : 's'} in this run` +
                        (configuredProviderIds.length > 0 ? ` (configured: ${configuredProviderIds.length})` : '');

                    tbody.innerHTML = rows.map(([id, stats]) => {
                        const rate = typeof stats.success_rate === 'number' ? stats.success_rate : 0;
                        const badgeClass = rate >= 90 ? 'excellent' : rate >= 70 ? 'good' : rate >= 50 ? 'fair' : 'poor';
                        const providerLabel = Object.prototype.hasOwnProperty.call(providerNames, id)
                            ? providerNames[id]
                            : `Provider ${id}`;
                        const providerMeta = providerMetadata[id] || {};
                        const maxStreams = typeof providerMeta.max_streams === 'number'
                            ? providerMeta.max_streams
                            : (providerMeta.max_streams === 0 ? 0 : '‚Äî');
                        const avgQuality = (stats.avg_quality === undefined || stats.avg_quality === null) ? '‚Äî' : stats.avg_quality;
                        const total = typeof stats.total === 'number' ? stats.total : 0;
                        const successful = typeof stats.successful === 'number' ? stats.successful : 0;
                        const failed = typeof stats.failed === 'number' ? stats.failed : 0;

                        return `<tr>
                            <td>${providerLabel}</td>
                            <td>${total}</td>
                            <td style="color: #38a169;">${successful}</td>
                            <td style="color: #e53e3e;">${failed}</td>
                            <td><span class="success-badge ${badgeClass}">${rate}%</span></td>
                            <td>${avgQuality}</td>
                            <td>${maxStreams}</td>
                        </tr>`;
                    }).join('');
                }

                // Default view matches prior behavior (only providers present in this run).
                renderProviders(false);
                showAllProvidersEl.checked = false;
                showAllProvidersEl.addEventListener('change', (e) => {
                    renderProviders(Boolean(e.target && e.target.checked));
                });
                
                // Channels
                const chanTbody = document.getElementById('channel-tbody');
                const channels = Object.entries(r.channel_stats || {}).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
                
                chanTbody.innerHTML = channels.map(([num, stats]) => {
                    const badgeClass = stats.success_rate >= 90 ? 'excellent' : stats.success_rate >= 70 ? 'good' : stats.success_rate >= 50 ? 'fair' : 'poor';
                    return `<tr>
                        <td><strong>#${num}</strong> ${stats.name}</td>
                        <td>${stats.total}</td>
                        <td style="color: #38a169;">${stats.successful}</td>
                        <td style="color: #e53e3e;">${stats.failed}</td>
                        <td><span class="success-badge ${badgeClass}">${stats.success_rate}%</span></td>
                    </tr>`;
                }).join('');
                
                // Errors
                const errors = Object.entries(r.error_types || {}).sort((a, b) => b[1] - a[1]);
                const errDiv = document.getElementById('error-list');
                
                if (errors.length === 0) {
                    errDiv.innerHTML = '<p style="color: #38a169;">‚úÖ No errors! All streams working perfectly!</p>';
                } else {
                    errDiv.innerHTML = errors.map(([type, count]) => 
                        `<div style="padding:12px;border-left:3px solid #e53e3e;background:#fff5f5;margin-bottom:10px;border-radius:5px;">
                            <div style="font-weight:600;color:#742a2a;">${type}</div>
                            <div style="color:#718096;font-size:0.9em;">${count} occurrence${count > 1 ? 's' : ''}</div>
                        </div>`
                    ).join('');
                }

                // If Streams is the default active tab, load it immediately.
                if (document.getElementById('streams-tab')?.classList.contains('active') && !streamsLoaded) {
                    loadStreams();
                }
            });
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');

            if (tabName === 'streams' && !streamsLoaded) {
                loadStreams();
            }
            if (tabName === 'plan' && !planLoaded) {
                loadPlan();
            }
        }

        function setStreamStatus(msg) {
            const el = document.getElementById('stream-regex-status');
            if (el) el.textContent = msg || '';
        }

        function updateStreamsCount() {
            const all = document.querySelectorAll('.stream-row');
            const checked = document.querySelectorAll('.stream-row input[type="checkbox"]:checked');
            const pill = document.getElementById('streams-count-pill');
            if (pill) pill.textContent = `${checked.length}/${all.length} selected`;
        }

        async function loadStreams() {
            streamsLoaded = true;
            const loadingEl = document.getElementById('streams-loading');
            if (loadingEl) loadingEl.textContent = 'Loading streams...';

            const url = jobId
                ? `/api/results/streams?job_id=${encodeURIComponent(jobId)}&limit=2000&offset=0`
                : `/api/results/streams?limit=2000&offset=0`;

            try {
                const resp = await fetch(url);
                const data = await resp.json();
                if (!data.success) {
                    if (loadingEl) loadingEl.textContent = data.error || 'Failed to load streams.';
                    return;
                }
                const rows = Array.isArray(data.streams) ? data.streams : [];
                const tbody = document.getElementById('stream-tbody');
                if (!tbody) return;

                tbody.innerHTML = rows.map((s) => {
                    const name = escapeHtml(s.stream_name || '(unnamed)');
                    const status = escapeHtml(s.status || '');
                    const quality = (typeof s.quality_score === 'number') ? s.quality_score.toFixed(1) : (s.quality_score ?? '');
                    const resolution = escapeHtml(s.resolution || '');
                    const provider = providerLabelHtml(s.provider_id);
                    const checkboxId = `use-stream-${escapeHtml(String(s.stream_id ?? Math.random()))}`;
                    return `
                        <tr class="stream-row" data-stream-name="${escapeHtml(String(s.stream_name || '')).toLowerCase()}" data-provider-id="${escapeHtml(String(s.provider_id ?? ''))}">
                            <td><input type="checkbox" id="${checkboxId}" class="stream-use-cb" checked onchange="updateStreamsCount()" /></td>
                            <td><label for="${checkboxId}" style="cursor:pointer;"><strong>${name}</strong></label></td>
                            <td>${status}</td>
                            <td>${escapeHtml(String(quality))}</td>
                            <td>${resolution}</td>
                            <td>${provider}</td>
                        </tr>
                    `;
                }).join('');

                if (loadingEl) loadingEl.textContent = rows.length ? `Loaded ${rows.length} stream rows.` : 'No streams found.';
                updateStreamsCount();
            } catch (e) {
                if (loadingEl) loadingEl.textContent = `Failed to load streams: ${e.message}`;
            }
        }

        function setPlanStatus(msg) {
            const el = document.getElementById('plan-status');
            if (el) el.textContent = msg || '';
        }

        function setPlanCount(n) {
            const pill = document.getElementById('plan-count-pill');
            if (pill) pill.textContent = `${n} channel${n === 1 ? '' : 's'}`;
        }

        function fmtChannelLabel(row) {
            const num = row && row.channel_number !== undefined && row.channel_number !== null ? String(row.channel_number) : '';
            const name = row && row.channel_name ? String(row.channel_name) : '';
            const id = row && row.channel_id !== undefined && row.channel_id !== null ? String(row.channel_id) : '';
            if (num && name) return `#${escapeHtml(num)} ${escapeHtml(name)} (id ${escapeHtml(id)})`;
            if (name) return `${escapeHtml(name)} (id ${escapeHtml(id)})`;
            return `Channel ${escapeHtml(id)}`;
        }

        async function loadPlan() {
            planLoaded = true;
            const tbody = document.getElementById('plan-tbody');
            const changedOnlyEl = document.getElementById('plan-changed-only');
            if (!tbody) return;

            if (!jobId) {
                setPlanStatus('Select a specific run (job_id) to view its plan.');
                tbody.innerHTML = '';
                setPlanCount(0);
                return;
            }

            async function fetchAndRender() {
                const changedOnly = Boolean(changedOnlyEl && changedOnlyEl.checked);
                setPlanStatus('Loading...');
                tbody.innerHTML = '';

                try {
                    const url = `/api/dispatcharr-plan/${encodeURIComponent(jobId)}?limit=2000&offset=0&changed_only=${changedOnly ? '1' : '0'}`;
                    const resp = await fetch(url);
                    const data = await resp.json();
                    if (!data.success) {
                        setPlanStatus(data.error || 'No plan available for this run.');
                        tbody.innerHTML = '';
                        setPlanCount(0);
                        return;
                    }

                    const rows = Array.isArray(data.rows) ? data.rows : [];
                    setPlanCount(data.total || rows.length || 0);
                    setPlanStatus(rows.length ? `Loaded ${rows.length} row(s).` : 'No planned changes.');

                    tbody.innerHTML = rows.map((r) => {
                        const beforeCount = Number.isFinite(r.before_count) ? r.before_count : (Array.isArray(r.before_stream_ids) ? r.before_stream_ids.length : 0);
                        const afterCount = Number.isFinite(r.after_count) ? r.after_count : (Array.isArray(r.after_stream_ids) ? r.after_stream_ids.length : 0);
                        const removedCount = Number.isFinite(r.removed_count) ? r.removed_count : (Array.isArray(r.removed_stream_ids) ? r.removed_stream_ids.length : 0);
                        const addedCount = Number.isFinite(r.added_count) ? r.added_count : (Array.isArray(r.added_stream_ids) ? r.added_stream_ids.length : 0);
                        const preview = Array.isArray(r.after_stream_ids) ? r.after_stream_ids.slice(0, 30) : [];
                        return `<tr>
                            <td><strong>${fmtChannelLabel(r)}</strong></td>
                            <td>${escapeHtml(String(beforeCount))}</td>
                            <td>${escapeHtml(String(afterCount))}</td>
                            <td style="color:#e53e3e;">${escapeHtml(String(removedCount))}</td>
                            <td style="color:#38a169;">${escapeHtml(String(addedCount))}</td>
                            <td class="small muted"><code>${escapeHtml(preview.join(', '))}${(Array.isArray(r.after_stream_ids) && r.after_stream_ids.length > 30) ? '‚Ä¶' : ''}</code></td>
                        </tr>`;
                    }).join('');
                } catch (e) {
                    setPlanStatus(`Failed to load plan: ${e.message}`);
                    tbody.innerHTML = '';
                    setPlanCount(0);
                }
            }

            if (changedOnlyEl) {
                changedOnlyEl.addEventListener('change', fetchAndRender);
            }
            await fetchAndRender();
        }

        function filterStreamRows() {
            const q = (document.getElementById('stream-search')?.value || '').trim().toLowerCase();
            document.querySelectorAll('.stream-row').forEach((row) => {
                const name = row.getAttribute('data-stream-name') || '';
                row.style.display = (!q || name.includes(q)) ? '' : 'none';
            });
            updateStreamsCount();
        }

        function selectAllStreams() {
            document.querySelectorAll('.stream-row input[type="checkbox"]').forEach(cb => { cb.checked = true; });
            updateStreamsCount();
        }

        function clearAllStreams() {
            document.querySelectorAll('.stream-row input[type="checkbox"]').forEach(cb => { cb.checked = false; });
            updateStreamsCount();
        }

        function getStreamIncludeExclude() {
            const include = [];
            const exclude = [];
            document.querySelectorAll('.stream-row').forEach((row) => {
                const name = row.querySelector('td:nth-child(2)')?.innerText?.trim() || '';
                const checked = row.querySelector('input[type="checkbox"]')?.checked;
                if (!name) return;
                if (checked) include.push(name);
                else exclude.push(name);
            });
            return { include, exclude };
        }

        async function generateStreamRegex() {
            setStreamStatus('Generating...');
            const { include, exclude } = getStreamIncludeExclude();
            const outBox = document.getElementById('stream-regex-output');
            const outCode = document.getElementById('stream-regex-code');
            const copyBtn = document.getElementById('copy-stream-regex-btn');

            if (!include.length) {
                setStreamStatus('Select at least one stream.');
                if (outBox) outBox.style.display = 'none';
                if (copyBtn) copyBtn.disabled = true;
                return;
            }

            try {
                const resp = await fetch('/api/regex/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ include, exclude })
                });
                const data = await resp.json();
                if (!data.success) {
                    setStreamStatus(data.error || 'Failed to generate regex.');
                    if (outBox) outBox.style.display = 'none';
                    if (copyBtn) copyBtn.disabled = true;
                    return;
                }
                const regex = data.regex || '';
                if (outCode) outCode.textContent = regex;
                if (outBox) outBox.style.display = 'block';
                if (copyBtn) copyBtn.disabled = !regex;
                setStreamStatus(`Suggested regex ready. Includes: ${include.length}, excludes: ${exclude.length}.`);
            } catch (e) {
                setStreamStatus(`Failed: ${e.message}`);
                if (outBox) outBox.style.display = 'none';
                if (copyBtn) copyBtn.disabled = true;
            }
        }

        async function copyStreamRegex() {
            const regexText = document.getElementById('stream-regex-code')?.textContent || '';
            if (!regexText) return;
            try {
                await navigator.clipboard.writeText(regexText);
                setStreamStatus('Copied regex to clipboard.');
            } catch {
                const ta = document.createElement('textarea');
                ta.value = regexText;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                setStreamStatus('Copied regex to clipboard.');
            }
        }
    </script>
</body>
</html>
